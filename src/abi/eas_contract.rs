// @generated
// This file was @generated by `substreams-ethereum-abigen`. Do not edit it by hand.

const INTERNAL_ERR: &'static str = "`ethabi_derive` internal error";
/// Contract's functions.
#[allow(dead_code, unused_imports, unused_variables)]
pub mod functions {
    use super::INTERNAL_ERR;
    #[derive(Debug, Clone, PartialEq)]
    pub struct Attest {
        pub request: (
            [u8; 32usize],
            (
                Vec<u8>,
                substreams::scalar::BigInt,
                bool,
                [u8; 32usize],
                Vec<u8>,
                substreams::scalar::BigInt,
            ),
        ),
    }
    impl Attest {
        const METHOD_ID: [u8; 4] = [241u8, 115u8, 37u8, 231u8];
        pub fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            let maybe_data = call.input.get(4..);
            if maybe_data.is_none() {
                return Err("no data to decode".to_string());
            }
            let mut values = ethabi::decode(
                    &[
                        ethabi::ParamType::Tuple(
                            vec![
                                ethabi::ParamType::FixedBytes(32usize),
                                ethabi::ParamType::Tuple(vec![ethabi::ParamType::Address,
                                ethabi::ParamType::Uint(64usize), ethabi::ParamType::Bool,
                                ethabi::ParamType::FixedBytes(32usize),
                                ethabi::ParamType::Bytes,
                                ethabi::ParamType::Uint(256usize)])
                            ],
                        ),
                    ],
                    maybe_data.unwrap(),
                )
                .map_err(|e| format!("unable to decode call.input: {:?}", e))?;
            values.reverse();
            Ok(Self {
                request: {
                    let tuple_elements = values
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_tuple()
                        .expect(INTERNAL_ERR);
                    (
                        {
                            let mut result = [0u8; 32];
                            let v = tuple_elements[0usize]
                                .clone()
                                .into_fixed_bytes()
                                .expect(INTERNAL_ERR);
                            result.copy_from_slice(&v);
                            result
                        },
                        {
                            let tuple_elements = tuple_elements[1usize]
                                .clone()
                                .into_tuple()
                                .expect(INTERNAL_ERR);
                            (
                                tuple_elements[0usize]
                                    .clone()
                                    .into_address()
                                    .expect(INTERNAL_ERR)
                                    .as_bytes()
                                    .to_vec(),
                                {
                                    let mut v = [0 as u8; 32];
                                    tuple_elements[1usize]
                                        .clone()
                                        .into_uint()
                                        .expect(INTERNAL_ERR)
                                        .to_big_endian(v.as_mut_slice());
                                    substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                                },
                                tuple_elements[2usize]
                                    .clone()
                                    .into_bool()
                                    .expect(INTERNAL_ERR),
                                {
                                    let mut result = [0u8; 32];
                                    let v = tuple_elements[3usize]
                                        .clone()
                                        .into_fixed_bytes()
                                        .expect(INTERNAL_ERR);
                                    result.copy_from_slice(&v);
                                    result
                                },
                                tuple_elements[4usize]
                                    .clone()
                                    .into_bytes()
                                    .expect(INTERNAL_ERR),
                                {
                                    let mut v = [0 as u8; 32];
                                    tuple_elements[5usize]
                                        .clone()
                                        .into_uint()
                                        .expect(INTERNAL_ERR)
                                        .to_big_endian(v.as_mut_slice());
                                    substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                                },
                            )
                        },
                    )
                },
            })
        }
        pub fn encode(&self) -> Vec<u8> {
            let data = ethabi::encode(
                &[
                    ethabi::Token::Tuple(
                        vec![
                            ethabi::Token::FixedBytes(self.request.0.as_ref().to_vec()),
                            ethabi::Token::Tuple(vec![ethabi::Token::Address(ethabi::Address::from_slice(&
                            self.request.1.0)),
                            ethabi::Token::Uint(ethabi::Uint::from_big_endian(match self
                            .request.1.1.clone().to_bytes_be() { (num_bigint::Sign::Plus,
                            bytes) => bytes, (num_bigint::Sign::NoSign, bytes) => bytes,
                            (num_bigint::Sign::Minus, _) => {
                            panic!("negative numbers are not supported") }, }
                            .as_slice(),),), ethabi::Token::Bool(self.request.1.2
                            .clone()), ethabi::Token::FixedBytes(self.request.1.3
                            .as_ref().to_vec()), ethabi::Token::Bytes(self.request.1.4
                            .clone()),
                            ethabi::Token::Uint(ethabi::Uint::from_big_endian(match self
                            .request.1.5.clone().to_bytes_be() { (num_bigint::Sign::Plus,
                            bytes) => bytes, (num_bigint::Sign::NoSign, bytes) => bytes,
                            (num_bigint::Sign::Minus, _) => {
                            panic!("negative numbers are not supported") }, }
                            .as_slice(),),)])
                        ],
                    ),
                ],
            );
            let mut encoded = Vec::with_capacity(4 + data.len());
            encoded.extend(Self::METHOD_ID);
            encoded.extend(data);
            encoded
        }
        pub fn output_call(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<[u8; 32usize], String> {
            Self::output(call.return_data.as_ref())
        }
        pub fn output(data: &[u8]) -> Result<[u8; 32usize], String> {
            let mut values = ethabi::decode(
                    &[ethabi::ParamType::FixedBytes(32usize)],
                    data.as_ref(),
                )
                .map_err(|e| format!("unable to decode output data: {:?}", e))?;
            Ok({
                let mut result = [0u8; 32];
                let v = values
                    .pop()
                    .expect("one output data should have existed")
                    .into_fixed_bytes()
                    .expect(INTERNAL_ERR);
                result.copy_from_slice(&v);
                result
            })
        }
        pub fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            match call.input.get(0..4) {
                Some(signature) => Self::METHOD_ID == signature,
                None => false,
            }
        }
        pub fn call(&self, address: Vec<u8>) -> Option<[u8; 32usize]> {
            use substreams_ethereum::pb::eth::rpc;
            let rpc_calls = rpc::RpcCalls {
                calls: vec![rpc::RpcCall { to_addr : address, data : self.encode(), }],
            };
            let responses = substreams_ethereum::rpc::eth_call(&rpc_calls).responses;
            let response = responses.get(0).expect("one response should have existed");
            if response.failed {
                return None;
            }
            match Self::output(response.raw.as_ref()) {
                Ok(data) => Some(data),
                Err(err) => {
                    use substreams_ethereum::Function;
                    substreams::log::info!(
                        "Call output for function `{}` failed to decode with error: {}",
                        Self::NAME, err
                    );
                    None
                }
            }
        }
    }
    impl substreams_ethereum::Function for Attest {
        const NAME: &'static str = "attest";
        fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            Self::match_call(call)
        }
        fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            Self::decode(call)
        }
        fn encode(&self) -> Vec<u8> {
            self.encode()
        }
    }
    impl substreams_ethereum::rpc::RPCDecodable<[u8; 32usize]> for Attest {
        fn output(data: &[u8]) -> Result<[u8; 32usize], String> {
            Self::output(data)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct AttestByDelegation {
        pub delegated_request: (
            [u8; 32usize],
            (
                Vec<u8>,
                substreams::scalar::BigInt,
                bool,
                [u8; 32usize],
                Vec<u8>,
                substreams::scalar::BigInt,
            ),
            (substreams::scalar::BigInt, [u8; 32usize], [u8; 32usize]),
            Vec<u8>,
        ),
    }
    impl AttestByDelegation {
        const METHOD_ID: [u8; 4] = [225u8, 52u8, 88u8, 252u8];
        pub fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            let maybe_data = call.input.get(4..);
            if maybe_data.is_none() {
                return Err("no data to decode".to_string());
            }
            let mut values = ethabi::decode(
                    &[
                        ethabi::ParamType::Tuple(
                            vec![
                                ethabi::ParamType::FixedBytes(32usize),
                                ethabi::ParamType::Tuple(vec![ethabi::ParamType::Address,
                                ethabi::ParamType::Uint(64usize), ethabi::ParamType::Bool,
                                ethabi::ParamType::FixedBytes(32usize),
                                ethabi::ParamType::Bytes,
                                ethabi::ParamType::Uint(256usize)]),
                                ethabi::ParamType::Tuple(vec![ethabi::ParamType::Uint(8usize),
                                ethabi::ParamType::FixedBytes(32usize),
                                ethabi::ParamType::FixedBytes(32usize)]),
                                ethabi::ParamType::Address
                            ],
                        ),
                    ],
                    maybe_data.unwrap(),
                )
                .map_err(|e| format!("unable to decode call.input: {:?}", e))?;
            values.reverse();
            Ok(Self {
                delegated_request: {
                    let tuple_elements = values
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_tuple()
                        .expect(INTERNAL_ERR);
                    (
                        {
                            let mut result = [0u8; 32];
                            let v = tuple_elements[0usize]
                                .clone()
                                .into_fixed_bytes()
                                .expect(INTERNAL_ERR);
                            result.copy_from_slice(&v);
                            result
                        },
                        {
                            let tuple_elements = tuple_elements[1usize]
                                .clone()
                                .into_tuple()
                                .expect(INTERNAL_ERR);
                            (
                                tuple_elements[0usize]
                                    .clone()
                                    .into_address()
                                    .expect(INTERNAL_ERR)
                                    .as_bytes()
                                    .to_vec(),
                                {
                                    let mut v = [0 as u8; 32];
                                    tuple_elements[1usize]
                                        .clone()
                                        .into_uint()
                                        .expect(INTERNAL_ERR)
                                        .to_big_endian(v.as_mut_slice());
                                    substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                                },
                                tuple_elements[2usize]
                                    .clone()
                                    .into_bool()
                                    .expect(INTERNAL_ERR),
                                {
                                    let mut result = [0u8; 32];
                                    let v = tuple_elements[3usize]
                                        .clone()
                                        .into_fixed_bytes()
                                        .expect(INTERNAL_ERR);
                                    result.copy_from_slice(&v);
                                    result
                                },
                                tuple_elements[4usize]
                                    .clone()
                                    .into_bytes()
                                    .expect(INTERNAL_ERR),
                                {
                                    let mut v = [0 as u8; 32];
                                    tuple_elements[5usize]
                                        .clone()
                                        .into_uint()
                                        .expect(INTERNAL_ERR)
                                        .to_big_endian(v.as_mut_slice());
                                    substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                                },
                            )
                        },
                        {
                            let tuple_elements = tuple_elements[2usize]
                                .clone()
                                .into_tuple()
                                .expect(INTERNAL_ERR);
                            (
                                {
                                    let mut v = [0 as u8; 32];
                                    tuple_elements[0usize]
                                        .clone()
                                        .into_uint()
                                        .expect(INTERNAL_ERR)
                                        .to_big_endian(v.as_mut_slice());
                                    substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                                },
                                {
                                    let mut result = [0u8; 32];
                                    let v = tuple_elements[1usize]
                                        .clone()
                                        .into_fixed_bytes()
                                        .expect(INTERNAL_ERR);
                                    result.copy_from_slice(&v);
                                    result
                                },
                                {
                                    let mut result = [0u8; 32];
                                    let v = tuple_elements[2usize]
                                        .clone()
                                        .into_fixed_bytes()
                                        .expect(INTERNAL_ERR);
                                    result.copy_from_slice(&v);
                                    result
                                },
                            )
                        },
                        tuple_elements[3usize]
                            .clone()
                            .into_address()
                            .expect(INTERNAL_ERR)
                            .as_bytes()
                            .to_vec(),
                    )
                },
            })
        }
        pub fn encode(&self) -> Vec<u8> {
            let data = ethabi::encode(
                &[
                    ethabi::Token::Tuple(
                        vec![
                            ethabi::Token::FixedBytes(self.delegated_request.0.as_ref()
                            .to_vec()),
                            ethabi::Token::Tuple(vec![ethabi::Token::Address(ethabi::Address::from_slice(&
                            self.delegated_request.1.0)),
                            ethabi::Token::Uint(ethabi::Uint::from_big_endian(match self
                            .delegated_request.1.1.clone().to_bytes_be() {
                            (num_bigint::Sign::Plus, bytes) => bytes,
                            (num_bigint::Sign::NoSign, bytes) => bytes,
                            (num_bigint::Sign::Minus, _) => {
                            panic!("negative numbers are not supported") }, }
                            .as_slice(),),), ethabi::Token::Bool(self.delegated_request.1
                            .2.clone()), ethabi::Token::FixedBytes(self.delegated_request
                            .1.3.as_ref().to_vec()), ethabi::Token::Bytes(self
                            .delegated_request.1.4.clone()),
                            ethabi::Token::Uint(ethabi::Uint::from_big_endian(match self
                            .delegated_request.1.5.clone().to_bytes_be() {
                            (num_bigint::Sign::Plus, bytes) => bytes,
                            (num_bigint::Sign::NoSign, bytes) => bytes,
                            (num_bigint::Sign::Minus, _) => {
                            panic!("negative numbers are not supported") }, }
                            .as_slice(),),)]),
                            ethabi::Token::Tuple(vec![ethabi::Token::Uint(ethabi::Uint::from_big_endian(match
                            self.delegated_request.2.0.clone().to_bytes_be() {
                            (num_bigint::Sign::Plus, bytes) => bytes,
                            (num_bigint::Sign::NoSign, bytes) => bytes,
                            (num_bigint::Sign::Minus, _) => {
                            panic!("negative numbers are not supported") }, }
                            .as_slice(),),), ethabi::Token::FixedBytes(self
                            .delegated_request.2.1.as_ref().to_vec()),
                            ethabi::Token::FixedBytes(self.delegated_request.2.2.as_ref()
                            .to_vec())]),
                            ethabi::Token::Address(ethabi::Address::from_slice(& self
                            .delegated_request.3))
                        ],
                    ),
                ],
            );
            let mut encoded = Vec::with_capacity(4 + data.len());
            encoded.extend(Self::METHOD_ID);
            encoded.extend(data);
            encoded
        }
        pub fn output_call(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<[u8; 32usize], String> {
            Self::output(call.return_data.as_ref())
        }
        pub fn output(data: &[u8]) -> Result<[u8; 32usize], String> {
            let mut values = ethabi::decode(
                    &[ethabi::ParamType::FixedBytes(32usize)],
                    data.as_ref(),
                )
                .map_err(|e| format!("unable to decode output data: {:?}", e))?;
            Ok({
                let mut result = [0u8; 32];
                let v = values
                    .pop()
                    .expect("one output data should have existed")
                    .into_fixed_bytes()
                    .expect(INTERNAL_ERR);
                result.copy_from_slice(&v);
                result
            })
        }
        pub fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            match call.input.get(0..4) {
                Some(signature) => Self::METHOD_ID == signature,
                None => false,
            }
        }
        pub fn call(&self, address: Vec<u8>) -> Option<[u8; 32usize]> {
            use substreams_ethereum::pb::eth::rpc;
            let rpc_calls = rpc::RpcCalls {
                calls: vec![rpc::RpcCall { to_addr : address, data : self.encode(), }],
            };
            let responses = substreams_ethereum::rpc::eth_call(&rpc_calls).responses;
            let response = responses.get(0).expect("one response should have existed");
            if response.failed {
                return None;
            }
            match Self::output(response.raw.as_ref()) {
                Ok(data) => Some(data),
                Err(err) => {
                    use substreams_ethereum::Function;
                    substreams::log::info!(
                        "Call output for function `{}` failed to decode with error: {}",
                        Self::NAME, err
                    );
                    None
                }
            }
        }
    }
    impl substreams_ethereum::Function for AttestByDelegation {
        const NAME: &'static str = "attestByDelegation";
        fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            Self::match_call(call)
        }
        fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            Self::decode(call)
        }
        fn encode(&self) -> Vec<u8> {
            self.encode()
        }
    }
    impl substreams_ethereum::rpc::RPCDecodable<[u8; 32usize]> for AttestByDelegation {
        fn output(data: &[u8]) -> Result<[u8; 32usize], String> {
            Self::output(data)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct GetAttestTypeHash {}
    impl GetAttestTypeHash {
        const METHOD_ID: [u8; 4] = [18u8, 177u8, 26u8, 23u8];
        pub fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            Ok(Self {})
        }
        pub fn encode(&self) -> Vec<u8> {
            let data = ethabi::encode(&[]);
            let mut encoded = Vec::with_capacity(4 + data.len());
            encoded.extend(Self::METHOD_ID);
            encoded.extend(data);
            encoded
        }
        pub fn output_call(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<[u8; 32usize], String> {
            Self::output(call.return_data.as_ref())
        }
        pub fn output(data: &[u8]) -> Result<[u8; 32usize], String> {
            let mut values = ethabi::decode(
                    &[ethabi::ParamType::FixedBytes(32usize)],
                    data.as_ref(),
                )
                .map_err(|e| format!("unable to decode output data: {:?}", e))?;
            Ok({
                let mut result = [0u8; 32];
                let v = values
                    .pop()
                    .expect("one output data should have existed")
                    .into_fixed_bytes()
                    .expect(INTERNAL_ERR);
                result.copy_from_slice(&v);
                result
            })
        }
        pub fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            match call.input.get(0..4) {
                Some(signature) => Self::METHOD_ID == signature,
                None => false,
            }
        }
        pub fn call(&self, address: Vec<u8>) -> Option<[u8; 32usize]> {
            use substreams_ethereum::pb::eth::rpc;
            let rpc_calls = rpc::RpcCalls {
                calls: vec![rpc::RpcCall { to_addr : address, data : self.encode(), }],
            };
            let responses = substreams_ethereum::rpc::eth_call(&rpc_calls).responses;
            let response = responses.get(0).expect("one response should have existed");
            if response.failed {
                return None;
            }
            match Self::output(response.raw.as_ref()) {
                Ok(data) => Some(data),
                Err(err) => {
                    use substreams_ethereum::Function;
                    substreams::log::info!(
                        "Call output for function `{}` failed to decode with error: {}",
                        Self::NAME, err
                    );
                    None
                }
            }
        }
    }
    impl substreams_ethereum::Function for GetAttestTypeHash {
        const NAME: &'static str = "getAttestTypeHash";
        fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            Self::match_call(call)
        }
        fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            Self::decode(call)
        }
        fn encode(&self) -> Vec<u8> {
            self.encode()
        }
    }
    impl substreams_ethereum::rpc::RPCDecodable<[u8; 32usize]> for GetAttestTypeHash {
        fn output(data: &[u8]) -> Result<[u8; 32usize], String> {
            Self::output(data)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct GetAttestation {
        pub uid: [u8; 32usize],
    }
    impl GetAttestation {
        const METHOD_ID: [u8; 4] = [163u8, 17u8, 42u8, 100u8];
        pub fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            let maybe_data = call.input.get(4..);
            if maybe_data.is_none() {
                return Err("no data to decode".to_string());
            }
            let mut values = ethabi::decode(
                    &[ethabi::ParamType::FixedBytes(32usize)],
                    maybe_data.unwrap(),
                )
                .map_err(|e| format!("unable to decode call.input: {:?}", e))?;
            values.reverse();
            Ok(Self {
                uid: {
                    let mut result = [0u8; 32];
                    let v = values
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_fixed_bytes()
                        .expect(INTERNAL_ERR);
                    result.copy_from_slice(&v);
                    result
                },
            })
        }
        pub fn encode(&self) -> Vec<u8> {
            let data = ethabi::encode(
                &[ethabi::Token::FixedBytes(self.uid.as_ref().to_vec())],
            );
            let mut encoded = Vec::with_capacity(4 + data.len());
            encoded.extend(Self::METHOD_ID);
            encoded.extend(data);
            encoded
        }
        pub fn output_call(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<
            (
                [u8; 32usize],
                [u8; 32usize],
                substreams::scalar::BigInt,
                substreams::scalar::BigInt,
                substreams::scalar::BigInt,
                [u8; 32usize],
                Vec<u8>,
                Vec<u8>,
                bool,
                Vec<u8>,
            ),
            String,
        > {
            Self::output(call.return_data.as_ref())
        }
        pub fn output(
            data: &[u8],
        ) -> Result<
            (
                [u8; 32usize],
                [u8; 32usize],
                substreams::scalar::BigInt,
                substreams::scalar::BigInt,
                substreams::scalar::BigInt,
                [u8; 32usize],
                Vec<u8>,
                Vec<u8>,
                bool,
                Vec<u8>,
            ),
            String,
        > {
            let mut values = ethabi::decode(
                    &[
                        ethabi::ParamType::Tuple(
                            vec![
                                ethabi::ParamType::FixedBytes(32usize),
                                ethabi::ParamType::FixedBytes(32usize),
                                ethabi::ParamType::Uint(64usize),
                                ethabi::ParamType::Uint(64usize),
                                ethabi::ParamType::Uint(64usize),
                                ethabi::ParamType::FixedBytes(32usize),
                                ethabi::ParamType::Address, ethabi::ParamType::Address,
                                ethabi::ParamType::Bool, ethabi::ParamType::Bytes
                            ],
                        ),
                    ],
                    data.as_ref(),
                )
                .map_err(|e| format!("unable to decode output data: {:?}", e))?;
            Ok({
                let tuple_elements = values
                    .pop()
                    .expect("one output data should have existed")
                    .into_tuple()
                    .expect(INTERNAL_ERR);
                (
                    {
                        let mut result = [0u8; 32];
                        let v = tuple_elements[0usize]
                            .clone()
                            .into_fixed_bytes()
                            .expect(INTERNAL_ERR);
                        result.copy_from_slice(&v);
                        result
                    },
                    {
                        let mut result = [0u8; 32];
                        let v = tuple_elements[1usize]
                            .clone()
                            .into_fixed_bytes()
                            .expect(INTERNAL_ERR);
                        result.copy_from_slice(&v);
                        result
                    },
                    {
                        let mut v = [0 as u8; 32];
                        tuple_elements[2usize]
                            .clone()
                            .into_uint()
                            .expect(INTERNAL_ERR)
                            .to_big_endian(v.as_mut_slice());
                        substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                    },
                    {
                        let mut v = [0 as u8; 32];
                        tuple_elements[3usize]
                            .clone()
                            .into_uint()
                            .expect(INTERNAL_ERR)
                            .to_big_endian(v.as_mut_slice());
                        substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                    },
                    {
                        let mut v = [0 as u8; 32];
                        tuple_elements[4usize]
                            .clone()
                            .into_uint()
                            .expect(INTERNAL_ERR)
                            .to_big_endian(v.as_mut_slice());
                        substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                    },
                    {
                        let mut result = [0u8; 32];
                        let v = tuple_elements[5usize]
                            .clone()
                            .into_fixed_bytes()
                            .expect(INTERNAL_ERR);
                        result.copy_from_slice(&v);
                        result
                    },
                    tuple_elements[6usize]
                        .clone()
                        .into_address()
                        .expect(INTERNAL_ERR)
                        .as_bytes()
                        .to_vec(),
                    tuple_elements[7usize]
                        .clone()
                        .into_address()
                        .expect(INTERNAL_ERR)
                        .as_bytes()
                        .to_vec(),
                    tuple_elements[8usize].clone().into_bool().expect(INTERNAL_ERR),
                    tuple_elements[9usize].clone().into_bytes().expect(INTERNAL_ERR),
                )
            })
        }
        pub fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            match call.input.get(0..4) {
                Some(signature) => Self::METHOD_ID == signature,
                None => false,
            }
        }
        pub fn call(
            &self,
            address: Vec<u8>,
        ) -> Option<
            (
                [u8; 32usize],
                [u8; 32usize],
                substreams::scalar::BigInt,
                substreams::scalar::BigInt,
                substreams::scalar::BigInt,
                [u8; 32usize],
                Vec<u8>,
                Vec<u8>,
                bool,
                Vec<u8>,
            ),
        > {
            use substreams_ethereum::pb::eth::rpc;
            let rpc_calls = rpc::RpcCalls {
                calls: vec![rpc::RpcCall { to_addr : address, data : self.encode(), }],
            };
            let responses = substreams_ethereum::rpc::eth_call(&rpc_calls).responses;
            let response = responses.get(0).expect("one response should have existed");
            if response.failed {
                return None;
            }
            match Self::output(response.raw.as_ref()) {
                Ok(data) => Some(data),
                Err(err) => {
                    use substreams_ethereum::Function;
                    substreams::log::info!(
                        "Call output for function `{}` failed to decode with error: {}",
                        Self::NAME, err
                    );
                    None
                }
            }
        }
    }
    impl substreams_ethereum::Function for GetAttestation {
        const NAME: &'static str = "getAttestation";
        fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            Self::match_call(call)
        }
        fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            Self::decode(call)
        }
        fn encode(&self) -> Vec<u8> {
            self.encode()
        }
    }
    impl substreams_ethereum::rpc::RPCDecodable<
        (
            [u8; 32usize],
            [u8; 32usize],
            substreams::scalar::BigInt,
            substreams::scalar::BigInt,
            substreams::scalar::BigInt,
            [u8; 32usize],
            Vec<u8>,
            Vec<u8>,
            bool,
            Vec<u8>,
        ),
    > for GetAttestation {
        fn output(
            data: &[u8],
        ) -> Result<
            (
                [u8; 32usize],
                [u8; 32usize],
                substreams::scalar::BigInt,
                substreams::scalar::BigInt,
                substreams::scalar::BigInt,
                [u8; 32usize],
                Vec<u8>,
                Vec<u8>,
                bool,
                Vec<u8>,
            ),
            String,
        > {
            Self::output(data)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct GetDomainSeparator {}
    impl GetDomainSeparator {
        const METHOD_ID: [u8; 4] = [237u8, 36u8, 145u8, 29u8];
        pub fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            Ok(Self {})
        }
        pub fn encode(&self) -> Vec<u8> {
            let data = ethabi::encode(&[]);
            let mut encoded = Vec::with_capacity(4 + data.len());
            encoded.extend(Self::METHOD_ID);
            encoded.extend(data);
            encoded
        }
        pub fn output_call(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<[u8; 32usize], String> {
            Self::output(call.return_data.as_ref())
        }
        pub fn output(data: &[u8]) -> Result<[u8; 32usize], String> {
            let mut values = ethabi::decode(
                    &[ethabi::ParamType::FixedBytes(32usize)],
                    data.as_ref(),
                )
                .map_err(|e| format!("unable to decode output data: {:?}", e))?;
            Ok({
                let mut result = [0u8; 32];
                let v = values
                    .pop()
                    .expect("one output data should have existed")
                    .into_fixed_bytes()
                    .expect(INTERNAL_ERR);
                result.copy_from_slice(&v);
                result
            })
        }
        pub fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            match call.input.get(0..4) {
                Some(signature) => Self::METHOD_ID == signature,
                None => false,
            }
        }
        pub fn call(&self, address: Vec<u8>) -> Option<[u8; 32usize]> {
            use substreams_ethereum::pb::eth::rpc;
            let rpc_calls = rpc::RpcCalls {
                calls: vec![rpc::RpcCall { to_addr : address, data : self.encode(), }],
            };
            let responses = substreams_ethereum::rpc::eth_call(&rpc_calls).responses;
            let response = responses.get(0).expect("one response should have existed");
            if response.failed {
                return None;
            }
            match Self::output(response.raw.as_ref()) {
                Ok(data) => Some(data),
                Err(err) => {
                    use substreams_ethereum::Function;
                    substreams::log::info!(
                        "Call output for function `{}` failed to decode with error: {}",
                        Self::NAME, err
                    );
                    None
                }
            }
        }
    }
    impl substreams_ethereum::Function for GetDomainSeparator {
        const NAME: &'static str = "getDomainSeparator";
        fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            Self::match_call(call)
        }
        fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            Self::decode(call)
        }
        fn encode(&self) -> Vec<u8> {
            self.encode()
        }
    }
    impl substreams_ethereum::rpc::RPCDecodable<[u8; 32usize]> for GetDomainSeparator {
        fn output(data: &[u8]) -> Result<[u8; 32usize], String> {
            Self::output(data)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct GetName {}
    impl GetName {
        const METHOD_ID: [u8; 4] = [23u8, 215u8, 222u8, 124u8];
        pub fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            Ok(Self {})
        }
        pub fn encode(&self) -> Vec<u8> {
            let data = ethabi::encode(&[]);
            let mut encoded = Vec::with_capacity(4 + data.len());
            encoded.extend(Self::METHOD_ID);
            encoded.extend(data);
            encoded
        }
        pub fn output_call(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<String, String> {
            Self::output(call.return_data.as_ref())
        }
        pub fn output(data: &[u8]) -> Result<String, String> {
            let mut values = ethabi::decode(&[ethabi::ParamType::String], data.as_ref())
                .map_err(|e| format!("unable to decode output data: {:?}", e))?;
            Ok(
                values
                    .pop()
                    .expect("one output data should have existed")
                    .into_string()
                    .expect(INTERNAL_ERR),
            )
        }
        pub fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            match call.input.get(0..4) {
                Some(signature) => Self::METHOD_ID == signature,
                None => false,
            }
        }
        pub fn call(&self, address: Vec<u8>) -> Option<String> {
            use substreams_ethereum::pb::eth::rpc;
            let rpc_calls = rpc::RpcCalls {
                calls: vec![rpc::RpcCall { to_addr : address, data : self.encode(), }],
            };
            let responses = substreams_ethereum::rpc::eth_call(&rpc_calls).responses;
            let response = responses.get(0).expect("one response should have existed");
            if response.failed {
                return None;
            }
            match Self::output(response.raw.as_ref()) {
                Ok(data) => Some(data),
                Err(err) => {
                    use substreams_ethereum::Function;
                    substreams::log::info!(
                        "Call output for function `{}` failed to decode with error: {}",
                        Self::NAME, err
                    );
                    None
                }
            }
        }
    }
    impl substreams_ethereum::Function for GetName {
        const NAME: &'static str = "getName";
        fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            Self::match_call(call)
        }
        fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            Self::decode(call)
        }
        fn encode(&self) -> Vec<u8> {
            self.encode()
        }
    }
    impl substreams_ethereum::rpc::RPCDecodable<String> for GetName {
        fn output(data: &[u8]) -> Result<String, String> {
            Self::output(data)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct GetNonce {
        pub account: Vec<u8>,
    }
    impl GetNonce {
        const METHOD_ID: [u8; 4] = [45u8, 3u8, 53u8, 171u8];
        pub fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            let maybe_data = call.input.get(4..);
            if maybe_data.is_none() {
                return Err("no data to decode".to_string());
            }
            let mut values = ethabi::decode(
                    &[ethabi::ParamType::Address],
                    maybe_data.unwrap(),
                )
                .map_err(|e| format!("unable to decode call.input: {:?}", e))?;
            values.reverse();
            Ok(Self {
                account: values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_address()
                    .expect(INTERNAL_ERR)
                    .as_bytes()
                    .to_vec(),
            })
        }
        pub fn encode(&self) -> Vec<u8> {
            let data = ethabi::encode(
                &[ethabi::Token::Address(ethabi::Address::from_slice(&self.account))],
            );
            let mut encoded = Vec::with_capacity(4 + data.len());
            encoded.extend(Self::METHOD_ID);
            encoded.extend(data);
            encoded
        }
        pub fn output_call(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<substreams::scalar::BigInt, String> {
            Self::output(call.return_data.as_ref())
        }
        pub fn output(data: &[u8]) -> Result<substreams::scalar::BigInt, String> {
            let mut values = ethabi::decode(
                    &[ethabi::ParamType::Uint(256usize)],
                    data.as_ref(),
                )
                .map_err(|e| format!("unable to decode output data: {:?}", e))?;
            Ok({
                let mut v = [0 as u8; 32];
                values
                    .pop()
                    .expect("one output data should have existed")
                    .into_uint()
                    .expect(INTERNAL_ERR)
                    .to_big_endian(v.as_mut_slice());
                substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
            })
        }
        pub fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            match call.input.get(0..4) {
                Some(signature) => Self::METHOD_ID == signature,
                None => false,
            }
        }
        pub fn call(&self, address: Vec<u8>) -> Option<substreams::scalar::BigInt> {
            use substreams_ethereum::pb::eth::rpc;
            let rpc_calls = rpc::RpcCalls {
                calls: vec![rpc::RpcCall { to_addr : address, data : self.encode(), }],
            };
            let responses = substreams_ethereum::rpc::eth_call(&rpc_calls).responses;
            let response = responses.get(0).expect("one response should have existed");
            if response.failed {
                return None;
            }
            match Self::output(response.raw.as_ref()) {
                Ok(data) => Some(data),
                Err(err) => {
                    use substreams_ethereum::Function;
                    substreams::log::info!(
                        "Call output for function `{}` failed to decode with error: {}",
                        Self::NAME, err
                    );
                    None
                }
            }
        }
    }
    impl substreams_ethereum::Function for GetNonce {
        const NAME: &'static str = "getNonce";
        fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            Self::match_call(call)
        }
        fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            Self::decode(call)
        }
        fn encode(&self) -> Vec<u8> {
            self.encode()
        }
    }
    impl substreams_ethereum::rpc::RPCDecodable<substreams::scalar::BigInt>
    for GetNonce {
        fn output(data: &[u8]) -> Result<substreams::scalar::BigInt, String> {
            Self::output(data)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct GetRevokeOffchain {
        pub revoker: Vec<u8>,
        pub data: [u8; 32usize],
    }
    impl GetRevokeOffchain {
        const METHOD_ID: [u8; 4] = [180u8, 105u8, 49u8, 141u8];
        pub fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            let maybe_data = call.input.get(4..);
            if maybe_data.is_none() {
                return Err("no data to decode".to_string());
            }
            let mut values = ethabi::decode(
                    &[
                        ethabi::ParamType::Address,
                        ethabi::ParamType::FixedBytes(32usize),
                    ],
                    maybe_data.unwrap(),
                )
                .map_err(|e| format!("unable to decode call.input: {:?}", e))?;
            values.reverse();
            Ok(Self {
                revoker: values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_address()
                    .expect(INTERNAL_ERR)
                    .as_bytes()
                    .to_vec(),
                data: {
                    let mut result = [0u8; 32];
                    let v = values
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_fixed_bytes()
                        .expect(INTERNAL_ERR);
                    result.copy_from_slice(&v);
                    result
                },
            })
        }
        pub fn encode(&self) -> Vec<u8> {
            let data = ethabi::encode(
                &[
                    ethabi::Token::Address(ethabi::Address::from_slice(&self.revoker)),
                    ethabi::Token::FixedBytes(self.data.as_ref().to_vec()),
                ],
            );
            let mut encoded = Vec::with_capacity(4 + data.len());
            encoded.extend(Self::METHOD_ID);
            encoded.extend(data);
            encoded
        }
        pub fn output_call(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<substreams::scalar::BigInt, String> {
            Self::output(call.return_data.as_ref())
        }
        pub fn output(data: &[u8]) -> Result<substreams::scalar::BigInt, String> {
            let mut values = ethabi::decode(
                    &[ethabi::ParamType::Uint(64usize)],
                    data.as_ref(),
                )
                .map_err(|e| format!("unable to decode output data: {:?}", e))?;
            Ok({
                let mut v = [0 as u8; 32];
                values
                    .pop()
                    .expect("one output data should have existed")
                    .into_uint()
                    .expect(INTERNAL_ERR)
                    .to_big_endian(v.as_mut_slice());
                substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
            })
        }
        pub fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            match call.input.get(0..4) {
                Some(signature) => Self::METHOD_ID == signature,
                None => false,
            }
        }
        pub fn call(&self, address: Vec<u8>) -> Option<substreams::scalar::BigInt> {
            use substreams_ethereum::pb::eth::rpc;
            let rpc_calls = rpc::RpcCalls {
                calls: vec![rpc::RpcCall { to_addr : address, data : self.encode(), }],
            };
            let responses = substreams_ethereum::rpc::eth_call(&rpc_calls).responses;
            let response = responses.get(0).expect("one response should have existed");
            if response.failed {
                return None;
            }
            match Self::output(response.raw.as_ref()) {
                Ok(data) => Some(data),
                Err(err) => {
                    use substreams_ethereum::Function;
                    substreams::log::info!(
                        "Call output for function `{}` failed to decode with error: {}",
                        Self::NAME, err
                    );
                    None
                }
            }
        }
    }
    impl substreams_ethereum::Function for GetRevokeOffchain {
        const NAME: &'static str = "getRevokeOffchain";
        fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            Self::match_call(call)
        }
        fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            Self::decode(call)
        }
        fn encode(&self) -> Vec<u8> {
            self.encode()
        }
    }
    impl substreams_ethereum::rpc::RPCDecodable<substreams::scalar::BigInt>
    for GetRevokeOffchain {
        fn output(data: &[u8]) -> Result<substreams::scalar::BigInt, String> {
            Self::output(data)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct GetRevokeTypeHash {}
    impl GetRevokeTypeHash {
        const METHOD_ID: [u8; 4] = [184u8, 48u8, 16u8, 211u8];
        pub fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            Ok(Self {})
        }
        pub fn encode(&self) -> Vec<u8> {
            let data = ethabi::encode(&[]);
            let mut encoded = Vec::with_capacity(4 + data.len());
            encoded.extend(Self::METHOD_ID);
            encoded.extend(data);
            encoded
        }
        pub fn output_call(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<[u8; 32usize], String> {
            Self::output(call.return_data.as_ref())
        }
        pub fn output(data: &[u8]) -> Result<[u8; 32usize], String> {
            let mut values = ethabi::decode(
                    &[ethabi::ParamType::FixedBytes(32usize)],
                    data.as_ref(),
                )
                .map_err(|e| format!("unable to decode output data: {:?}", e))?;
            Ok({
                let mut result = [0u8; 32];
                let v = values
                    .pop()
                    .expect("one output data should have existed")
                    .into_fixed_bytes()
                    .expect(INTERNAL_ERR);
                result.copy_from_slice(&v);
                result
            })
        }
        pub fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            match call.input.get(0..4) {
                Some(signature) => Self::METHOD_ID == signature,
                None => false,
            }
        }
        pub fn call(&self, address: Vec<u8>) -> Option<[u8; 32usize]> {
            use substreams_ethereum::pb::eth::rpc;
            let rpc_calls = rpc::RpcCalls {
                calls: vec![rpc::RpcCall { to_addr : address, data : self.encode(), }],
            };
            let responses = substreams_ethereum::rpc::eth_call(&rpc_calls).responses;
            let response = responses.get(0).expect("one response should have existed");
            if response.failed {
                return None;
            }
            match Self::output(response.raw.as_ref()) {
                Ok(data) => Some(data),
                Err(err) => {
                    use substreams_ethereum::Function;
                    substreams::log::info!(
                        "Call output for function `{}` failed to decode with error: {}",
                        Self::NAME, err
                    );
                    None
                }
            }
        }
    }
    impl substreams_ethereum::Function for GetRevokeTypeHash {
        const NAME: &'static str = "getRevokeTypeHash";
        fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            Self::match_call(call)
        }
        fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            Self::decode(call)
        }
        fn encode(&self) -> Vec<u8> {
            self.encode()
        }
    }
    impl substreams_ethereum::rpc::RPCDecodable<[u8; 32usize]> for GetRevokeTypeHash {
        fn output(data: &[u8]) -> Result<[u8; 32usize], String> {
            Self::output(data)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct GetSchemaRegistry {}
    impl GetSchemaRegistry {
        const METHOD_ID: [u8; 4] = [241u8, 11u8, 92u8, 200u8];
        pub fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            Ok(Self {})
        }
        pub fn encode(&self) -> Vec<u8> {
            let data = ethabi::encode(&[]);
            let mut encoded = Vec::with_capacity(4 + data.len());
            encoded.extend(Self::METHOD_ID);
            encoded.extend(data);
            encoded
        }
        pub fn output_call(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Vec<u8>, String> {
            Self::output(call.return_data.as_ref())
        }
        pub fn output(data: &[u8]) -> Result<Vec<u8>, String> {
            let mut values = ethabi::decode(&[ethabi::ParamType::Address], data.as_ref())
                .map_err(|e| format!("unable to decode output data: {:?}", e))?;
            Ok(
                values
                    .pop()
                    .expect("one output data should have existed")
                    .into_address()
                    .expect(INTERNAL_ERR)
                    .as_bytes()
                    .to_vec(),
            )
        }
        pub fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            match call.input.get(0..4) {
                Some(signature) => Self::METHOD_ID == signature,
                None => false,
            }
        }
        pub fn call(&self, address: Vec<u8>) -> Option<Vec<u8>> {
            use substreams_ethereum::pb::eth::rpc;
            let rpc_calls = rpc::RpcCalls {
                calls: vec![rpc::RpcCall { to_addr : address, data : self.encode(), }],
            };
            let responses = substreams_ethereum::rpc::eth_call(&rpc_calls).responses;
            let response = responses.get(0).expect("one response should have existed");
            if response.failed {
                return None;
            }
            match Self::output(response.raw.as_ref()) {
                Ok(data) => Some(data),
                Err(err) => {
                    use substreams_ethereum::Function;
                    substreams::log::info!(
                        "Call output for function `{}` failed to decode with error: {}",
                        Self::NAME, err
                    );
                    None
                }
            }
        }
    }
    impl substreams_ethereum::Function for GetSchemaRegistry {
        const NAME: &'static str = "getSchemaRegistry";
        fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            Self::match_call(call)
        }
        fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            Self::decode(call)
        }
        fn encode(&self) -> Vec<u8> {
            self.encode()
        }
    }
    impl substreams_ethereum::rpc::RPCDecodable<Vec<u8>> for GetSchemaRegistry {
        fn output(data: &[u8]) -> Result<Vec<u8>, String> {
            Self::output(data)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct GetTimestamp {
        pub data: [u8; 32usize],
    }
    impl GetTimestamp {
        const METHOD_ID: [u8; 4] = [212u8, 92u8, 68u8, 53u8];
        pub fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            let maybe_data = call.input.get(4..);
            if maybe_data.is_none() {
                return Err("no data to decode".to_string());
            }
            let mut values = ethabi::decode(
                    &[ethabi::ParamType::FixedBytes(32usize)],
                    maybe_data.unwrap(),
                )
                .map_err(|e| format!("unable to decode call.input: {:?}", e))?;
            values.reverse();
            Ok(Self {
                data: {
                    let mut result = [0u8; 32];
                    let v = values
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_fixed_bytes()
                        .expect(INTERNAL_ERR);
                    result.copy_from_slice(&v);
                    result
                },
            })
        }
        pub fn encode(&self) -> Vec<u8> {
            let data = ethabi::encode(
                &[ethabi::Token::FixedBytes(self.data.as_ref().to_vec())],
            );
            let mut encoded = Vec::with_capacity(4 + data.len());
            encoded.extend(Self::METHOD_ID);
            encoded.extend(data);
            encoded
        }
        pub fn output_call(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<substreams::scalar::BigInt, String> {
            Self::output(call.return_data.as_ref())
        }
        pub fn output(data: &[u8]) -> Result<substreams::scalar::BigInt, String> {
            let mut values = ethabi::decode(
                    &[ethabi::ParamType::Uint(64usize)],
                    data.as_ref(),
                )
                .map_err(|e| format!("unable to decode output data: {:?}", e))?;
            Ok({
                let mut v = [0 as u8; 32];
                values
                    .pop()
                    .expect("one output data should have existed")
                    .into_uint()
                    .expect(INTERNAL_ERR)
                    .to_big_endian(v.as_mut_slice());
                substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
            })
        }
        pub fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            match call.input.get(0..4) {
                Some(signature) => Self::METHOD_ID == signature,
                None => false,
            }
        }
        pub fn call(&self, address: Vec<u8>) -> Option<substreams::scalar::BigInt> {
            use substreams_ethereum::pb::eth::rpc;
            let rpc_calls = rpc::RpcCalls {
                calls: vec![rpc::RpcCall { to_addr : address, data : self.encode(), }],
            };
            let responses = substreams_ethereum::rpc::eth_call(&rpc_calls).responses;
            let response = responses.get(0).expect("one response should have existed");
            if response.failed {
                return None;
            }
            match Self::output(response.raw.as_ref()) {
                Ok(data) => Some(data),
                Err(err) => {
                    use substreams_ethereum::Function;
                    substreams::log::info!(
                        "Call output for function `{}` failed to decode with error: {}",
                        Self::NAME, err
                    );
                    None
                }
            }
        }
    }
    impl substreams_ethereum::Function for GetTimestamp {
        const NAME: &'static str = "getTimestamp";
        fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            Self::match_call(call)
        }
        fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            Self::decode(call)
        }
        fn encode(&self) -> Vec<u8> {
            self.encode()
        }
    }
    impl substreams_ethereum::rpc::RPCDecodable<substreams::scalar::BigInt>
    for GetTimestamp {
        fn output(data: &[u8]) -> Result<substreams::scalar::BigInt, String> {
            Self::output(data)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct IsAttestationValid {
        pub uid: [u8; 32usize],
    }
    impl IsAttestationValid {
        const METHOD_ID: [u8; 4] = [227u8, 11u8, 181u8, 99u8];
        pub fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            let maybe_data = call.input.get(4..);
            if maybe_data.is_none() {
                return Err("no data to decode".to_string());
            }
            let mut values = ethabi::decode(
                    &[ethabi::ParamType::FixedBytes(32usize)],
                    maybe_data.unwrap(),
                )
                .map_err(|e| format!("unable to decode call.input: {:?}", e))?;
            values.reverse();
            Ok(Self {
                uid: {
                    let mut result = [0u8; 32];
                    let v = values
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_fixed_bytes()
                        .expect(INTERNAL_ERR);
                    result.copy_from_slice(&v);
                    result
                },
            })
        }
        pub fn encode(&self) -> Vec<u8> {
            let data = ethabi::encode(
                &[ethabi::Token::FixedBytes(self.uid.as_ref().to_vec())],
            );
            let mut encoded = Vec::with_capacity(4 + data.len());
            encoded.extend(Self::METHOD_ID);
            encoded.extend(data);
            encoded
        }
        pub fn output_call(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<bool, String> {
            Self::output(call.return_data.as_ref())
        }
        pub fn output(data: &[u8]) -> Result<bool, String> {
            let mut values = ethabi::decode(&[ethabi::ParamType::Bool], data.as_ref())
                .map_err(|e| format!("unable to decode output data: {:?}", e))?;
            Ok(
                values
                    .pop()
                    .expect("one output data should have existed")
                    .into_bool()
                    .expect(INTERNAL_ERR),
            )
        }
        pub fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            match call.input.get(0..4) {
                Some(signature) => Self::METHOD_ID == signature,
                None => false,
            }
        }
        pub fn call(&self, address: Vec<u8>) -> Option<bool> {
            use substreams_ethereum::pb::eth::rpc;
            let rpc_calls = rpc::RpcCalls {
                calls: vec![rpc::RpcCall { to_addr : address, data : self.encode(), }],
            };
            let responses = substreams_ethereum::rpc::eth_call(&rpc_calls).responses;
            let response = responses.get(0).expect("one response should have existed");
            if response.failed {
                return None;
            }
            match Self::output(response.raw.as_ref()) {
                Ok(data) => Some(data),
                Err(err) => {
                    use substreams_ethereum::Function;
                    substreams::log::info!(
                        "Call output for function `{}` failed to decode with error: {}",
                        Self::NAME, err
                    );
                    None
                }
            }
        }
    }
    impl substreams_ethereum::Function for IsAttestationValid {
        const NAME: &'static str = "isAttestationValid";
        fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            Self::match_call(call)
        }
        fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            Self::decode(call)
        }
        fn encode(&self) -> Vec<u8> {
            self.encode()
        }
    }
    impl substreams_ethereum::rpc::RPCDecodable<bool> for IsAttestationValid {
        fn output(data: &[u8]) -> Result<bool, String> {
            Self::output(data)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MultiAttest {
        pub multi_requests: Vec<
            (
                [u8; 32usize],
                Vec<
                    (
                        Vec<u8>,
                        substreams::scalar::BigInt,
                        bool,
                        [u8; 32usize],
                        Vec<u8>,
                        substreams::scalar::BigInt,
                    ),
                >,
            ),
        >,
    }
    impl MultiAttest {
        const METHOD_ID: [u8; 4] = [68u8, 173u8, 201u8, 14u8];
        pub fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            let maybe_data = call.input.get(4..);
            if maybe_data.is_none() {
                return Err("no data to decode".to_string());
            }
            let mut values = ethabi::decode(
                    &[
                        ethabi::ParamType::Array(
                            Box::new(
                                ethabi::ParamType::Tuple(
                                    vec![
                                        ethabi::ParamType::FixedBytes(32usize),
                                        ethabi::ParamType::Array(Box::new(ethabi::ParamType::Tuple(vec![ethabi::ParamType::Address,
                                        ethabi::ParamType::Uint(64usize), ethabi::ParamType::Bool,
                                        ethabi::ParamType::FixedBytes(32usize),
                                        ethabi::ParamType::Bytes,
                                        ethabi::ParamType::Uint(256usize)])))
                                    ],
                                ),
                            ),
                        ),
                    ],
                    maybe_data.unwrap(),
                )
                .map_err(|e| format!("unable to decode call.input: {:?}", e))?;
            values.reverse();
            Ok(Self {
                multi_requests: values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_array()
                    .expect(INTERNAL_ERR)
                    .into_iter()
                    .map(|inner| {
                        let tuple_elements = inner.into_tuple().expect(INTERNAL_ERR);
                        (
                            {
                                let mut result = [0u8; 32];
                                let v = tuple_elements[0usize]
                                    .clone()
                                    .into_fixed_bytes()
                                    .expect(INTERNAL_ERR);
                                result.copy_from_slice(&v);
                                result
                            },
                            tuple_elements[1usize]
                                .clone()
                                .into_array()
                                .expect(INTERNAL_ERR)
                                .into_iter()
                                .map(|inner| {
                                    let tuple_elements = inner
                                        .into_tuple()
                                        .expect(INTERNAL_ERR);
                                    (
                                        tuple_elements[0usize]
                                            .clone()
                                            .into_address()
                                            .expect(INTERNAL_ERR)
                                            .as_bytes()
                                            .to_vec(),
                                        {
                                            let mut v = [0 as u8; 32];
                                            tuple_elements[1usize]
                                                .clone()
                                                .into_uint()
                                                .expect(INTERNAL_ERR)
                                                .to_big_endian(v.as_mut_slice());
                                            substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                                        },
                                        tuple_elements[2usize]
                                            .clone()
                                            .into_bool()
                                            .expect(INTERNAL_ERR),
                                        {
                                            let mut result = [0u8; 32];
                                            let v = tuple_elements[3usize]
                                                .clone()
                                                .into_fixed_bytes()
                                                .expect(INTERNAL_ERR);
                                            result.copy_from_slice(&v);
                                            result
                                        },
                                        tuple_elements[4usize]
                                            .clone()
                                            .into_bytes()
                                            .expect(INTERNAL_ERR),
                                        {
                                            let mut v = [0 as u8; 32];
                                            tuple_elements[5usize]
                                                .clone()
                                                .into_uint()
                                                .expect(INTERNAL_ERR)
                                                .to_big_endian(v.as_mut_slice());
                                            substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                                        },
                                    )
                                })
                                .collect(),
                        )
                    })
                    .collect(),
            })
        }
        pub fn encode(&self) -> Vec<u8> {
            let data = ethabi::encode(
                &[
                    {
                        let v = self
                            .multi_requests
                            .iter()
                            .map(|inner| ethabi::Token::Tuple(
                                vec![
                                    ethabi::Token::FixedBytes(inner.0.as_ref().to_vec()), { let
                                    v = inner.1.iter().map(| inner |
                                    ethabi::Token::Tuple(vec![ethabi::Token::Address(ethabi::Address::from_slice(&
                                    inner.0)),
                                    ethabi::Token::Uint(ethabi::Uint::from_big_endian(match
                                    inner.1.clone().to_bytes_be() { (num_bigint::Sign::Plus,
                                    bytes) => bytes, (num_bigint::Sign::NoSign, bytes) => bytes,
                                    (num_bigint::Sign::Minus, _) => {
                                    panic!("negative numbers are not supported") }, }
                                    .as_slice(),),), ethabi::Token::Bool(inner.2.clone()),
                                    ethabi::Token::FixedBytes(inner.3.as_ref().to_vec()),
                                    ethabi::Token::Bytes(inner.4.clone()),
                                    ethabi::Token::Uint(ethabi::Uint::from_big_endian(match
                                    inner.5.clone().to_bytes_be() { (num_bigint::Sign::Plus,
                                    bytes) => bytes, (num_bigint::Sign::NoSign, bytes) => bytes,
                                    (num_bigint::Sign::Minus, _) => {
                                    panic!("negative numbers are not supported") }, }
                                    .as_slice(),),)])).collect(); ethabi::Token::Array(v) }
                                ],
                            ))
                            .collect();
                        ethabi::Token::Array(v)
                    },
                ],
            );
            let mut encoded = Vec::with_capacity(4 + data.len());
            encoded.extend(Self::METHOD_ID);
            encoded.extend(data);
            encoded
        }
        pub fn output_call(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Vec<[u8; 32usize]>, String> {
            Self::output(call.return_data.as_ref())
        }
        pub fn output(data: &[u8]) -> Result<Vec<[u8; 32usize]>, String> {
            let mut values = ethabi::decode(
                    &[
                        ethabi::ParamType::Array(
                            Box::new(ethabi::ParamType::FixedBytes(32usize)),
                        ),
                    ],
                    data.as_ref(),
                )
                .map_err(|e| format!("unable to decode output data: {:?}", e))?;
            Ok(
                values
                    .pop()
                    .expect("one output data should have existed")
                    .into_array()
                    .expect(INTERNAL_ERR)
                    .into_iter()
                    .map(|inner| {
                        let mut result = [0u8; 32];
                        let v = inner.into_fixed_bytes().expect(INTERNAL_ERR);
                        result.copy_from_slice(&v);
                        result
                    })
                    .collect(),
            )
        }
        pub fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            match call.input.get(0..4) {
                Some(signature) => Self::METHOD_ID == signature,
                None => false,
            }
        }
        pub fn call(&self, address: Vec<u8>) -> Option<Vec<[u8; 32usize]>> {
            use substreams_ethereum::pb::eth::rpc;
            let rpc_calls = rpc::RpcCalls {
                calls: vec![rpc::RpcCall { to_addr : address, data : self.encode(), }],
            };
            let responses = substreams_ethereum::rpc::eth_call(&rpc_calls).responses;
            let response = responses.get(0).expect("one response should have existed");
            if response.failed {
                return None;
            }
            match Self::output(response.raw.as_ref()) {
                Ok(data) => Some(data),
                Err(err) => {
                    use substreams_ethereum::Function;
                    substreams::log::info!(
                        "Call output for function `{}` failed to decode with error: {}",
                        Self::NAME, err
                    );
                    None
                }
            }
        }
    }
    impl substreams_ethereum::Function for MultiAttest {
        const NAME: &'static str = "multiAttest";
        fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            Self::match_call(call)
        }
        fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            Self::decode(call)
        }
        fn encode(&self) -> Vec<u8> {
            self.encode()
        }
    }
    impl substreams_ethereum::rpc::RPCDecodable<Vec<[u8; 32usize]>> for MultiAttest {
        fn output(data: &[u8]) -> Result<Vec<[u8; 32usize]>, String> {
            Self::output(data)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MultiAttestByDelegation {
        pub multi_delegated_requests: Vec<
            (
                [u8; 32usize],
                Vec<
                    (
                        Vec<u8>,
                        substreams::scalar::BigInt,
                        bool,
                        [u8; 32usize],
                        Vec<u8>,
                        substreams::scalar::BigInt,
                    ),
                >,
                Vec<(substreams::scalar::BigInt, [u8; 32usize], [u8; 32usize])>,
                Vec<u8>,
            ),
        >,
    }
    impl MultiAttestByDelegation {
        const METHOD_ID: [u8; 4] = [131u8, 30u8, 5u8, 161u8];
        pub fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            let maybe_data = call.input.get(4..);
            if maybe_data.is_none() {
                return Err("no data to decode".to_string());
            }
            let mut values = ethabi::decode(
                    &[
                        ethabi::ParamType::Array(
                            Box::new(
                                ethabi::ParamType::Tuple(
                                    vec![
                                        ethabi::ParamType::FixedBytes(32usize),
                                        ethabi::ParamType::Array(Box::new(ethabi::ParamType::Tuple(vec![ethabi::ParamType::Address,
                                        ethabi::ParamType::Uint(64usize), ethabi::ParamType::Bool,
                                        ethabi::ParamType::FixedBytes(32usize),
                                        ethabi::ParamType::Bytes,
                                        ethabi::ParamType::Uint(256usize)]))),
                                        ethabi::ParamType::Array(Box::new(ethabi::ParamType::Tuple(vec![ethabi::ParamType::Uint(8usize),
                                        ethabi::ParamType::FixedBytes(32usize),
                                        ethabi::ParamType::FixedBytes(32usize)]))),
                                        ethabi::ParamType::Address
                                    ],
                                ),
                            ),
                        ),
                    ],
                    maybe_data.unwrap(),
                )
                .map_err(|e| format!("unable to decode call.input: {:?}", e))?;
            values.reverse();
            Ok(Self {
                multi_delegated_requests: values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_array()
                    .expect(INTERNAL_ERR)
                    .into_iter()
                    .map(|inner| {
                        let tuple_elements = inner.into_tuple().expect(INTERNAL_ERR);
                        (
                            {
                                let mut result = [0u8; 32];
                                let v = tuple_elements[0usize]
                                    .clone()
                                    .into_fixed_bytes()
                                    .expect(INTERNAL_ERR);
                                result.copy_from_slice(&v);
                                result
                            },
                            tuple_elements[1usize]
                                .clone()
                                .into_array()
                                .expect(INTERNAL_ERR)
                                .into_iter()
                                .map(|inner| {
                                    let tuple_elements = inner
                                        .into_tuple()
                                        .expect(INTERNAL_ERR);
                                    (
                                        tuple_elements[0usize]
                                            .clone()
                                            .into_address()
                                            .expect(INTERNAL_ERR)
                                            .as_bytes()
                                            .to_vec(),
                                        {
                                            let mut v = [0 as u8; 32];
                                            tuple_elements[1usize]
                                                .clone()
                                                .into_uint()
                                                .expect(INTERNAL_ERR)
                                                .to_big_endian(v.as_mut_slice());
                                            substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                                        },
                                        tuple_elements[2usize]
                                            .clone()
                                            .into_bool()
                                            .expect(INTERNAL_ERR),
                                        {
                                            let mut result = [0u8; 32];
                                            let v = tuple_elements[3usize]
                                                .clone()
                                                .into_fixed_bytes()
                                                .expect(INTERNAL_ERR);
                                            result.copy_from_slice(&v);
                                            result
                                        },
                                        tuple_elements[4usize]
                                            .clone()
                                            .into_bytes()
                                            .expect(INTERNAL_ERR),
                                        {
                                            let mut v = [0 as u8; 32];
                                            tuple_elements[5usize]
                                                .clone()
                                                .into_uint()
                                                .expect(INTERNAL_ERR)
                                                .to_big_endian(v.as_mut_slice());
                                            substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                                        },
                                    )
                                })
                                .collect(),
                            tuple_elements[2usize]
                                .clone()
                                .into_array()
                                .expect(INTERNAL_ERR)
                                .into_iter()
                                .map(|inner| {
                                    let tuple_elements = inner
                                        .into_tuple()
                                        .expect(INTERNAL_ERR);
                                    (
                                        {
                                            let mut v = [0 as u8; 32];
                                            tuple_elements[0usize]
                                                .clone()
                                                .into_uint()
                                                .expect(INTERNAL_ERR)
                                                .to_big_endian(v.as_mut_slice());
                                            substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                                        },
                                        {
                                            let mut result = [0u8; 32];
                                            let v = tuple_elements[1usize]
                                                .clone()
                                                .into_fixed_bytes()
                                                .expect(INTERNAL_ERR);
                                            result.copy_from_slice(&v);
                                            result
                                        },
                                        {
                                            let mut result = [0u8; 32];
                                            let v = tuple_elements[2usize]
                                                .clone()
                                                .into_fixed_bytes()
                                                .expect(INTERNAL_ERR);
                                            result.copy_from_slice(&v);
                                            result
                                        },
                                    )
                                })
                                .collect(),
                            tuple_elements[3usize]
                                .clone()
                                .into_address()
                                .expect(INTERNAL_ERR)
                                .as_bytes()
                                .to_vec(),
                        )
                    })
                    .collect(),
            })
        }
        pub fn encode(&self) -> Vec<u8> {
            let data = ethabi::encode(
                &[
                    {
                        let v = self
                            .multi_delegated_requests
                            .iter()
                            .map(|inner| ethabi::Token::Tuple(
                                vec![
                                    ethabi::Token::FixedBytes(inner.0.as_ref().to_vec()), { let
                                    v = inner.1.iter().map(| inner |
                                    ethabi::Token::Tuple(vec![ethabi::Token::Address(ethabi::Address::from_slice(&
                                    inner.0)),
                                    ethabi::Token::Uint(ethabi::Uint::from_big_endian(match
                                    inner.1.clone().to_bytes_be() { (num_bigint::Sign::Plus,
                                    bytes) => bytes, (num_bigint::Sign::NoSign, bytes) => bytes,
                                    (num_bigint::Sign::Minus, _) => {
                                    panic!("negative numbers are not supported") }, }
                                    .as_slice(),),), ethabi::Token::Bool(inner.2.clone()),
                                    ethabi::Token::FixedBytes(inner.3.as_ref().to_vec()),
                                    ethabi::Token::Bytes(inner.4.clone()),
                                    ethabi::Token::Uint(ethabi::Uint::from_big_endian(match
                                    inner.5.clone().to_bytes_be() { (num_bigint::Sign::Plus,
                                    bytes) => bytes, (num_bigint::Sign::NoSign, bytes) => bytes,
                                    (num_bigint::Sign::Minus, _) => {
                                    panic!("negative numbers are not supported") }, }
                                    .as_slice(),),)])).collect(); ethabi::Token::Array(v) }, {
                                    let v = inner.2.iter().map(| inner |
                                    ethabi::Token::Tuple(vec![ethabi::Token::Uint(ethabi::Uint::from_big_endian(match
                                    inner.0.clone().to_bytes_be() { (num_bigint::Sign::Plus,
                                    bytes) => bytes, (num_bigint::Sign::NoSign, bytes) => bytes,
                                    (num_bigint::Sign::Minus, _) => {
                                    panic!("negative numbers are not supported") }, }
                                    .as_slice(),),), ethabi::Token::FixedBytes(inner.1.as_ref()
                                    .to_vec()), ethabi::Token::FixedBytes(inner.2.as_ref()
                                    .to_vec())])).collect(); ethabi::Token::Array(v) },
                                    ethabi::Token::Address(ethabi::Address::from_slice(& inner
                                    .3))
                                ],
                            ))
                            .collect();
                        ethabi::Token::Array(v)
                    },
                ],
            );
            let mut encoded = Vec::with_capacity(4 + data.len());
            encoded.extend(Self::METHOD_ID);
            encoded.extend(data);
            encoded
        }
        pub fn output_call(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Vec<[u8; 32usize]>, String> {
            Self::output(call.return_data.as_ref())
        }
        pub fn output(data: &[u8]) -> Result<Vec<[u8; 32usize]>, String> {
            let mut values = ethabi::decode(
                    &[
                        ethabi::ParamType::Array(
                            Box::new(ethabi::ParamType::FixedBytes(32usize)),
                        ),
                    ],
                    data.as_ref(),
                )
                .map_err(|e| format!("unable to decode output data: {:?}", e))?;
            Ok(
                values
                    .pop()
                    .expect("one output data should have existed")
                    .into_array()
                    .expect(INTERNAL_ERR)
                    .into_iter()
                    .map(|inner| {
                        let mut result = [0u8; 32];
                        let v = inner.into_fixed_bytes().expect(INTERNAL_ERR);
                        result.copy_from_slice(&v);
                        result
                    })
                    .collect(),
            )
        }
        pub fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            match call.input.get(0..4) {
                Some(signature) => Self::METHOD_ID == signature,
                None => false,
            }
        }
        pub fn call(&self, address: Vec<u8>) -> Option<Vec<[u8; 32usize]>> {
            use substreams_ethereum::pb::eth::rpc;
            let rpc_calls = rpc::RpcCalls {
                calls: vec![rpc::RpcCall { to_addr : address, data : self.encode(), }],
            };
            let responses = substreams_ethereum::rpc::eth_call(&rpc_calls).responses;
            let response = responses.get(0).expect("one response should have existed");
            if response.failed {
                return None;
            }
            match Self::output(response.raw.as_ref()) {
                Ok(data) => Some(data),
                Err(err) => {
                    use substreams_ethereum::Function;
                    substreams::log::info!(
                        "Call output for function `{}` failed to decode with error: {}",
                        Self::NAME, err
                    );
                    None
                }
            }
        }
    }
    impl substreams_ethereum::Function for MultiAttestByDelegation {
        const NAME: &'static str = "multiAttestByDelegation";
        fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            Self::match_call(call)
        }
        fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            Self::decode(call)
        }
        fn encode(&self) -> Vec<u8> {
            self.encode()
        }
    }
    impl substreams_ethereum::rpc::RPCDecodable<Vec<[u8; 32usize]>>
    for MultiAttestByDelegation {
        fn output(data: &[u8]) -> Result<Vec<[u8; 32usize]>, String> {
            Self::output(data)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MultiRevoke {
        pub multi_requests: Vec<
            ([u8; 32usize], Vec<([u8; 32usize], substreams::scalar::BigInt)>),
        >,
    }
    impl MultiRevoke {
        const METHOD_ID: [u8; 4] = [76u8, 183u8, 233u8, 229u8];
        pub fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            let maybe_data = call.input.get(4..);
            if maybe_data.is_none() {
                return Err("no data to decode".to_string());
            }
            let mut values = ethabi::decode(
                    &[
                        ethabi::ParamType::Array(
                            Box::new(
                                ethabi::ParamType::Tuple(
                                    vec![
                                        ethabi::ParamType::FixedBytes(32usize),
                                        ethabi::ParamType::Array(Box::new(ethabi::ParamType::Tuple(vec![ethabi::ParamType::FixedBytes(32usize),
                                        ethabi::ParamType::Uint(256usize)])))
                                    ],
                                ),
                            ),
                        ),
                    ],
                    maybe_data.unwrap(),
                )
                .map_err(|e| format!("unable to decode call.input: {:?}", e))?;
            values.reverse();
            Ok(Self {
                multi_requests: values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_array()
                    .expect(INTERNAL_ERR)
                    .into_iter()
                    .map(|inner| {
                        let tuple_elements = inner.into_tuple().expect(INTERNAL_ERR);
                        (
                            {
                                let mut result = [0u8; 32];
                                let v = tuple_elements[0usize]
                                    .clone()
                                    .into_fixed_bytes()
                                    .expect(INTERNAL_ERR);
                                result.copy_from_slice(&v);
                                result
                            },
                            tuple_elements[1usize]
                                .clone()
                                .into_array()
                                .expect(INTERNAL_ERR)
                                .into_iter()
                                .map(|inner| {
                                    let tuple_elements = inner
                                        .into_tuple()
                                        .expect(INTERNAL_ERR);
                                    (
                                        {
                                            let mut result = [0u8; 32];
                                            let v = tuple_elements[0usize]
                                                .clone()
                                                .into_fixed_bytes()
                                                .expect(INTERNAL_ERR);
                                            result.copy_from_slice(&v);
                                            result
                                        },
                                        {
                                            let mut v = [0 as u8; 32];
                                            tuple_elements[1usize]
                                                .clone()
                                                .into_uint()
                                                .expect(INTERNAL_ERR)
                                                .to_big_endian(v.as_mut_slice());
                                            substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                                        },
                                    )
                                })
                                .collect(),
                        )
                    })
                    .collect(),
            })
        }
        pub fn encode(&self) -> Vec<u8> {
            let data = ethabi::encode(
                &[
                    {
                        let v = self
                            .multi_requests
                            .iter()
                            .map(|inner| ethabi::Token::Tuple(
                                vec![
                                    ethabi::Token::FixedBytes(inner.0.as_ref().to_vec()), { let
                                    v = inner.1.iter().map(| inner |
                                    ethabi::Token::Tuple(vec![ethabi::Token::FixedBytes(inner.0
                                    .as_ref().to_vec()),
                                    ethabi::Token::Uint(ethabi::Uint::from_big_endian(match
                                    inner.1.clone().to_bytes_be() { (num_bigint::Sign::Plus,
                                    bytes) => bytes, (num_bigint::Sign::NoSign, bytes) => bytes,
                                    (num_bigint::Sign::Minus, _) => {
                                    panic!("negative numbers are not supported") }, }
                                    .as_slice(),),)])).collect(); ethabi::Token::Array(v) }
                                ],
                            ))
                            .collect();
                        ethabi::Token::Array(v)
                    },
                ],
            );
            let mut encoded = Vec::with_capacity(4 + data.len());
            encoded.extend(Self::METHOD_ID);
            encoded.extend(data);
            encoded
        }
        pub fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            match call.input.get(0..4) {
                Some(signature) => Self::METHOD_ID == signature,
                None => false,
            }
        }
    }
    impl substreams_ethereum::Function for MultiRevoke {
        const NAME: &'static str = "multiRevoke";
        fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            Self::match_call(call)
        }
        fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            Self::decode(call)
        }
        fn encode(&self) -> Vec<u8> {
            self.encode()
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MultiRevokeByDelegation {
        pub multi_delegated_requests: Vec<
            (
                [u8; 32usize],
                Vec<([u8; 32usize], substreams::scalar::BigInt)>,
                Vec<(substreams::scalar::BigInt, [u8; 32usize], [u8; 32usize])>,
                Vec<u8>,
            ),
        >,
    }
    impl MultiRevokeByDelegation {
        const METHOD_ID: [u8; 4] = [228u8, 93u8, 3u8, 249u8];
        pub fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            let maybe_data = call.input.get(4..);
            if maybe_data.is_none() {
                return Err("no data to decode".to_string());
            }
            let mut values = ethabi::decode(
                    &[
                        ethabi::ParamType::Array(
                            Box::new(
                                ethabi::ParamType::Tuple(
                                    vec![
                                        ethabi::ParamType::FixedBytes(32usize),
                                        ethabi::ParamType::Array(Box::new(ethabi::ParamType::Tuple(vec![ethabi::ParamType::FixedBytes(32usize),
                                        ethabi::ParamType::Uint(256usize)]))),
                                        ethabi::ParamType::Array(Box::new(ethabi::ParamType::Tuple(vec![ethabi::ParamType::Uint(8usize),
                                        ethabi::ParamType::FixedBytes(32usize),
                                        ethabi::ParamType::FixedBytes(32usize)]))),
                                        ethabi::ParamType::Address
                                    ],
                                ),
                            ),
                        ),
                    ],
                    maybe_data.unwrap(),
                )
                .map_err(|e| format!("unable to decode call.input: {:?}", e))?;
            values.reverse();
            Ok(Self {
                multi_delegated_requests: values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_array()
                    .expect(INTERNAL_ERR)
                    .into_iter()
                    .map(|inner| {
                        let tuple_elements = inner.into_tuple().expect(INTERNAL_ERR);
                        (
                            {
                                let mut result = [0u8; 32];
                                let v = tuple_elements[0usize]
                                    .clone()
                                    .into_fixed_bytes()
                                    .expect(INTERNAL_ERR);
                                result.copy_from_slice(&v);
                                result
                            },
                            tuple_elements[1usize]
                                .clone()
                                .into_array()
                                .expect(INTERNAL_ERR)
                                .into_iter()
                                .map(|inner| {
                                    let tuple_elements = inner
                                        .into_tuple()
                                        .expect(INTERNAL_ERR);
                                    (
                                        {
                                            let mut result = [0u8; 32];
                                            let v = tuple_elements[0usize]
                                                .clone()
                                                .into_fixed_bytes()
                                                .expect(INTERNAL_ERR);
                                            result.copy_from_slice(&v);
                                            result
                                        },
                                        {
                                            let mut v = [0 as u8; 32];
                                            tuple_elements[1usize]
                                                .clone()
                                                .into_uint()
                                                .expect(INTERNAL_ERR)
                                                .to_big_endian(v.as_mut_slice());
                                            substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                                        },
                                    )
                                })
                                .collect(),
                            tuple_elements[2usize]
                                .clone()
                                .into_array()
                                .expect(INTERNAL_ERR)
                                .into_iter()
                                .map(|inner| {
                                    let tuple_elements = inner
                                        .into_tuple()
                                        .expect(INTERNAL_ERR);
                                    (
                                        {
                                            let mut v = [0 as u8; 32];
                                            tuple_elements[0usize]
                                                .clone()
                                                .into_uint()
                                                .expect(INTERNAL_ERR)
                                                .to_big_endian(v.as_mut_slice());
                                            substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                                        },
                                        {
                                            let mut result = [0u8; 32];
                                            let v = tuple_elements[1usize]
                                                .clone()
                                                .into_fixed_bytes()
                                                .expect(INTERNAL_ERR);
                                            result.copy_from_slice(&v);
                                            result
                                        },
                                        {
                                            let mut result = [0u8; 32];
                                            let v = tuple_elements[2usize]
                                                .clone()
                                                .into_fixed_bytes()
                                                .expect(INTERNAL_ERR);
                                            result.copy_from_slice(&v);
                                            result
                                        },
                                    )
                                })
                                .collect(),
                            tuple_elements[3usize]
                                .clone()
                                .into_address()
                                .expect(INTERNAL_ERR)
                                .as_bytes()
                                .to_vec(),
                        )
                    })
                    .collect(),
            })
        }
        pub fn encode(&self) -> Vec<u8> {
            let data = ethabi::encode(
                &[
                    {
                        let v = self
                            .multi_delegated_requests
                            .iter()
                            .map(|inner| ethabi::Token::Tuple(
                                vec![
                                    ethabi::Token::FixedBytes(inner.0.as_ref().to_vec()), { let
                                    v = inner.1.iter().map(| inner |
                                    ethabi::Token::Tuple(vec![ethabi::Token::FixedBytes(inner.0
                                    .as_ref().to_vec()),
                                    ethabi::Token::Uint(ethabi::Uint::from_big_endian(match
                                    inner.1.clone().to_bytes_be() { (num_bigint::Sign::Plus,
                                    bytes) => bytes, (num_bigint::Sign::NoSign, bytes) => bytes,
                                    (num_bigint::Sign::Minus, _) => {
                                    panic!("negative numbers are not supported") }, }
                                    .as_slice(),),)])).collect(); ethabi::Token::Array(v) }, {
                                    let v = inner.2.iter().map(| inner |
                                    ethabi::Token::Tuple(vec![ethabi::Token::Uint(ethabi::Uint::from_big_endian(match
                                    inner.0.clone().to_bytes_be() { (num_bigint::Sign::Plus,
                                    bytes) => bytes, (num_bigint::Sign::NoSign, bytes) => bytes,
                                    (num_bigint::Sign::Minus, _) => {
                                    panic!("negative numbers are not supported") }, }
                                    .as_slice(),),), ethabi::Token::FixedBytes(inner.1.as_ref()
                                    .to_vec()), ethabi::Token::FixedBytes(inner.2.as_ref()
                                    .to_vec())])).collect(); ethabi::Token::Array(v) },
                                    ethabi::Token::Address(ethabi::Address::from_slice(& inner
                                    .3))
                                ],
                            ))
                            .collect();
                        ethabi::Token::Array(v)
                    },
                ],
            );
            let mut encoded = Vec::with_capacity(4 + data.len());
            encoded.extend(Self::METHOD_ID);
            encoded.extend(data);
            encoded
        }
        pub fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            match call.input.get(0..4) {
                Some(signature) => Self::METHOD_ID == signature,
                None => false,
            }
        }
    }
    impl substreams_ethereum::Function for MultiRevokeByDelegation {
        const NAME: &'static str = "multiRevokeByDelegation";
        fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            Self::match_call(call)
        }
        fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            Self::decode(call)
        }
        fn encode(&self) -> Vec<u8> {
            self.encode()
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MultiRevokeOffchain {
        pub data: Vec<[u8; 32usize]>,
    }
    impl MultiRevokeOffchain {
        const METHOD_ID: [u8; 4] = [19u8, 137u8, 63u8, 97u8];
        pub fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            let maybe_data = call.input.get(4..);
            if maybe_data.is_none() {
                return Err("no data to decode".to_string());
            }
            let mut values = ethabi::decode(
                    &[
                        ethabi::ParamType::Array(
                            Box::new(ethabi::ParamType::FixedBytes(32usize)),
                        ),
                    ],
                    maybe_data.unwrap(),
                )
                .map_err(|e| format!("unable to decode call.input: {:?}", e))?;
            values.reverse();
            Ok(Self {
                data: values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_array()
                    .expect(INTERNAL_ERR)
                    .into_iter()
                    .map(|inner| {
                        let mut result = [0u8; 32];
                        let v = inner.into_fixed_bytes().expect(INTERNAL_ERR);
                        result.copy_from_slice(&v);
                        result
                    })
                    .collect(),
            })
        }
        pub fn encode(&self) -> Vec<u8> {
            let data = ethabi::encode(
                &[
                    {
                        let v = self
                            .data
                            .iter()
                            .map(|inner| ethabi::Token::FixedBytes(
                                inner.as_ref().to_vec(),
                            ))
                            .collect();
                        ethabi::Token::Array(v)
                    },
                ],
            );
            let mut encoded = Vec::with_capacity(4 + data.len());
            encoded.extend(Self::METHOD_ID);
            encoded.extend(data);
            encoded
        }
        pub fn output_call(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<substreams::scalar::BigInt, String> {
            Self::output(call.return_data.as_ref())
        }
        pub fn output(data: &[u8]) -> Result<substreams::scalar::BigInt, String> {
            let mut values = ethabi::decode(
                    &[ethabi::ParamType::Uint(64usize)],
                    data.as_ref(),
                )
                .map_err(|e| format!("unable to decode output data: {:?}", e))?;
            Ok({
                let mut v = [0 as u8; 32];
                values
                    .pop()
                    .expect("one output data should have existed")
                    .into_uint()
                    .expect(INTERNAL_ERR)
                    .to_big_endian(v.as_mut_slice());
                substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
            })
        }
        pub fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            match call.input.get(0..4) {
                Some(signature) => Self::METHOD_ID == signature,
                None => false,
            }
        }
        pub fn call(&self, address: Vec<u8>) -> Option<substreams::scalar::BigInt> {
            use substreams_ethereum::pb::eth::rpc;
            let rpc_calls = rpc::RpcCalls {
                calls: vec![rpc::RpcCall { to_addr : address, data : self.encode(), }],
            };
            let responses = substreams_ethereum::rpc::eth_call(&rpc_calls).responses;
            let response = responses.get(0).expect("one response should have existed");
            if response.failed {
                return None;
            }
            match Self::output(response.raw.as_ref()) {
                Ok(data) => Some(data),
                Err(err) => {
                    use substreams_ethereum::Function;
                    substreams::log::info!(
                        "Call output for function `{}` failed to decode with error: {}",
                        Self::NAME, err
                    );
                    None
                }
            }
        }
    }
    impl substreams_ethereum::Function for MultiRevokeOffchain {
        const NAME: &'static str = "multiRevokeOffchain";
        fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            Self::match_call(call)
        }
        fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            Self::decode(call)
        }
        fn encode(&self) -> Vec<u8> {
            self.encode()
        }
    }
    impl substreams_ethereum::rpc::RPCDecodable<substreams::scalar::BigInt>
    for MultiRevokeOffchain {
        fn output(data: &[u8]) -> Result<substreams::scalar::BigInt, String> {
            Self::output(data)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct MultiTimestamp {
        pub data: Vec<[u8; 32usize]>,
    }
    impl MultiTimestamp {
        const METHOD_ID: [u8; 4] = [231u8, 31u8, 243u8, 101u8];
        pub fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            let maybe_data = call.input.get(4..);
            if maybe_data.is_none() {
                return Err("no data to decode".to_string());
            }
            let mut values = ethabi::decode(
                    &[
                        ethabi::ParamType::Array(
                            Box::new(ethabi::ParamType::FixedBytes(32usize)),
                        ),
                    ],
                    maybe_data.unwrap(),
                )
                .map_err(|e| format!("unable to decode call.input: {:?}", e))?;
            values.reverse();
            Ok(Self {
                data: values
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_array()
                    .expect(INTERNAL_ERR)
                    .into_iter()
                    .map(|inner| {
                        let mut result = [0u8; 32];
                        let v = inner.into_fixed_bytes().expect(INTERNAL_ERR);
                        result.copy_from_slice(&v);
                        result
                    })
                    .collect(),
            })
        }
        pub fn encode(&self) -> Vec<u8> {
            let data = ethabi::encode(
                &[
                    {
                        let v = self
                            .data
                            .iter()
                            .map(|inner| ethabi::Token::FixedBytes(
                                inner.as_ref().to_vec(),
                            ))
                            .collect();
                        ethabi::Token::Array(v)
                    },
                ],
            );
            let mut encoded = Vec::with_capacity(4 + data.len());
            encoded.extend(Self::METHOD_ID);
            encoded.extend(data);
            encoded
        }
        pub fn output_call(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<substreams::scalar::BigInt, String> {
            Self::output(call.return_data.as_ref())
        }
        pub fn output(data: &[u8]) -> Result<substreams::scalar::BigInt, String> {
            let mut values = ethabi::decode(
                    &[ethabi::ParamType::Uint(64usize)],
                    data.as_ref(),
                )
                .map_err(|e| format!("unable to decode output data: {:?}", e))?;
            Ok({
                let mut v = [0 as u8; 32];
                values
                    .pop()
                    .expect("one output data should have existed")
                    .into_uint()
                    .expect(INTERNAL_ERR)
                    .to_big_endian(v.as_mut_slice());
                substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
            })
        }
        pub fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            match call.input.get(0..4) {
                Some(signature) => Self::METHOD_ID == signature,
                None => false,
            }
        }
        pub fn call(&self, address: Vec<u8>) -> Option<substreams::scalar::BigInt> {
            use substreams_ethereum::pb::eth::rpc;
            let rpc_calls = rpc::RpcCalls {
                calls: vec![rpc::RpcCall { to_addr : address, data : self.encode(), }],
            };
            let responses = substreams_ethereum::rpc::eth_call(&rpc_calls).responses;
            let response = responses.get(0).expect("one response should have existed");
            if response.failed {
                return None;
            }
            match Self::output(response.raw.as_ref()) {
                Ok(data) => Some(data),
                Err(err) => {
                    use substreams_ethereum::Function;
                    substreams::log::info!(
                        "Call output for function `{}` failed to decode with error: {}",
                        Self::NAME, err
                    );
                    None
                }
            }
        }
    }
    impl substreams_ethereum::Function for MultiTimestamp {
        const NAME: &'static str = "multiTimestamp";
        fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            Self::match_call(call)
        }
        fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            Self::decode(call)
        }
        fn encode(&self) -> Vec<u8> {
            self.encode()
        }
    }
    impl substreams_ethereum::rpc::RPCDecodable<substreams::scalar::BigInt>
    for MultiTimestamp {
        fn output(data: &[u8]) -> Result<substreams::scalar::BigInt, String> {
            Self::output(data)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct Revoke {
        pub request: ([u8; 32usize], ([u8; 32usize], substreams::scalar::BigInt)),
    }
    impl Revoke {
        const METHOD_ID: [u8; 4] = [70u8, 146u8, 98u8, 103u8];
        pub fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            let maybe_data = call.input.get(4..);
            if maybe_data.is_none() {
                return Err("no data to decode".to_string());
            }
            let mut values = ethabi::decode(
                    &[
                        ethabi::ParamType::Tuple(
                            vec![
                                ethabi::ParamType::FixedBytes(32usize),
                                ethabi::ParamType::Tuple(vec![ethabi::ParamType::FixedBytes(32usize),
                                ethabi::ParamType::Uint(256usize)])
                            ],
                        ),
                    ],
                    maybe_data.unwrap(),
                )
                .map_err(|e| format!("unable to decode call.input: {:?}", e))?;
            values.reverse();
            Ok(Self {
                request: {
                    let tuple_elements = values
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_tuple()
                        .expect(INTERNAL_ERR);
                    (
                        {
                            let mut result = [0u8; 32];
                            let v = tuple_elements[0usize]
                                .clone()
                                .into_fixed_bytes()
                                .expect(INTERNAL_ERR);
                            result.copy_from_slice(&v);
                            result
                        },
                        {
                            let tuple_elements = tuple_elements[1usize]
                                .clone()
                                .into_tuple()
                                .expect(INTERNAL_ERR);
                            (
                                {
                                    let mut result = [0u8; 32];
                                    let v = tuple_elements[0usize]
                                        .clone()
                                        .into_fixed_bytes()
                                        .expect(INTERNAL_ERR);
                                    result.copy_from_slice(&v);
                                    result
                                },
                                {
                                    let mut v = [0 as u8; 32];
                                    tuple_elements[1usize]
                                        .clone()
                                        .into_uint()
                                        .expect(INTERNAL_ERR)
                                        .to_big_endian(v.as_mut_slice());
                                    substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                                },
                            )
                        },
                    )
                },
            })
        }
        pub fn encode(&self) -> Vec<u8> {
            let data = ethabi::encode(
                &[
                    ethabi::Token::Tuple(
                        vec![
                            ethabi::Token::FixedBytes(self.request.0.as_ref().to_vec()),
                            ethabi::Token::Tuple(vec![ethabi::Token::FixedBytes(self
                            .request.1.0.as_ref().to_vec()),
                            ethabi::Token::Uint(ethabi::Uint::from_big_endian(match self
                            .request.1.1.clone().to_bytes_be() { (num_bigint::Sign::Plus,
                            bytes) => bytes, (num_bigint::Sign::NoSign, bytes) => bytes,
                            (num_bigint::Sign::Minus, _) => {
                            panic!("negative numbers are not supported") }, }
                            .as_slice(),),)])
                        ],
                    ),
                ],
            );
            let mut encoded = Vec::with_capacity(4 + data.len());
            encoded.extend(Self::METHOD_ID);
            encoded.extend(data);
            encoded
        }
        pub fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            match call.input.get(0..4) {
                Some(signature) => Self::METHOD_ID == signature,
                None => false,
            }
        }
    }
    impl substreams_ethereum::Function for Revoke {
        const NAME: &'static str = "revoke";
        fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            Self::match_call(call)
        }
        fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            Self::decode(call)
        }
        fn encode(&self) -> Vec<u8> {
            self.encode()
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct RevokeByDelegation {
        pub delegated_request: (
            [u8; 32usize],
            ([u8; 32usize], substreams::scalar::BigInt),
            (substreams::scalar::BigInt, [u8; 32usize], [u8; 32usize]),
            Vec<u8>,
        ),
    }
    impl RevokeByDelegation {
        const METHOD_ID: [u8; 4] = [229u8, 122u8, 107u8, 27u8];
        pub fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            let maybe_data = call.input.get(4..);
            if maybe_data.is_none() {
                return Err("no data to decode".to_string());
            }
            let mut values = ethabi::decode(
                    &[
                        ethabi::ParamType::Tuple(
                            vec![
                                ethabi::ParamType::FixedBytes(32usize),
                                ethabi::ParamType::Tuple(vec![ethabi::ParamType::FixedBytes(32usize),
                                ethabi::ParamType::Uint(256usize)]),
                                ethabi::ParamType::Tuple(vec![ethabi::ParamType::Uint(8usize),
                                ethabi::ParamType::FixedBytes(32usize),
                                ethabi::ParamType::FixedBytes(32usize)]),
                                ethabi::ParamType::Address
                            ],
                        ),
                    ],
                    maybe_data.unwrap(),
                )
                .map_err(|e| format!("unable to decode call.input: {:?}", e))?;
            values.reverse();
            Ok(Self {
                delegated_request: {
                    let tuple_elements = values
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_tuple()
                        .expect(INTERNAL_ERR);
                    (
                        {
                            let mut result = [0u8; 32];
                            let v = tuple_elements[0usize]
                                .clone()
                                .into_fixed_bytes()
                                .expect(INTERNAL_ERR);
                            result.copy_from_slice(&v);
                            result
                        },
                        {
                            let tuple_elements = tuple_elements[1usize]
                                .clone()
                                .into_tuple()
                                .expect(INTERNAL_ERR);
                            (
                                {
                                    let mut result = [0u8; 32];
                                    let v = tuple_elements[0usize]
                                        .clone()
                                        .into_fixed_bytes()
                                        .expect(INTERNAL_ERR);
                                    result.copy_from_slice(&v);
                                    result
                                },
                                {
                                    let mut v = [0 as u8; 32];
                                    tuple_elements[1usize]
                                        .clone()
                                        .into_uint()
                                        .expect(INTERNAL_ERR)
                                        .to_big_endian(v.as_mut_slice());
                                    substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                                },
                            )
                        },
                        {
                            let tuple_elements = tuple_elements[2usize]
                                .clone()
                                .into_tuple()
                                .expect(INTERNAL_ERR);
                            (
                                {
                                    let mut v = [0 as u8; 32];
                                    tuple_elements[0usize]
                                        .clone()
                                        .into_uint()
                                        .expect(INTERNAL_ERR)
                                        .to_big_endian(v.as_mut_slice());
                                    substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                                },
                                {
                                    let mut result = [0u8; 32];
                                    let v = tuple_elements[1usize]
                                        .clone()
                                        .into_fixed_bytes()
                                        .expect(INTERNAL_ERR);
                                    result.copy_from_slice(&v);
                                    result
                                },
                                {
                                    let mut result = [0u8; 32];
                                    let v = tuple_elements[2usize]
                                        .clone()
                                        .into_fixed_bytes()
                                        .expect(INTERNAL_ERR);
                                    result.copy_from_slice(&v);
                                    result
                                },
                            )
                        },
                        tuple_elements[3usize]
                            .clone()
                            .into_address()
                            .expect(INTERNAL_ERR)
                            .as_bytes()
                            .to_vec(),
                    )
                },
            })
        }
        pub fn encode(&self) -> Vec<u8> {
            let data = ethabi::encode(
                &[
                    ethabi::Token::Tuple(
                        vec![
                            ethabi::Token::FixedBytes(self.delegated_request.0.as_ref()
                            .to_vec()),
                            ethabi::Token::Tuple(vec![ethabi::Token::FixedBytes(self
                            .delegated_request.1.0.as_ref().to_vec()),
                            ethabi::Token::Uint(ethabi::Uint::from_big_endian(match self
                            .delegated_request.1.1.clone().to_bytes_be() {
                            (num_bigint::Sign::Plus, bytes) => bytes,
                            (num_bigint::Sign::NoSign, bytes) => bytes,
                            (num_bigint::Sign::Minus, _) => {
                            panic!("negative numbers are not supported") }, }
                            .as_slice(),),)]),
                            ethabi::Token::Tuple(vec![ethabi::Token::Uint(ethabi::Uint::from_big_endian(match
                            self.delegated_request.2.0.clone().to_bytes_be() {
                            (num_bigint::Sign::Plus, bytes) => bytes,
                            (num_bigint::Sign::NoSign, bytes) => bytes,
                            (num_bigint::Sign::Minus, _) => {
                            panic!("negative numbers are not supported") }, }
                            .as_slice(),),), ethabi::Token::FixedBytes(self
                            .delegated_request.2.1.as_ref().to_vec()),
                            ethabi::Token::FixedBytes(self.delegated_request.2.2.as_ref()
                            .to_vec())]),
                            ethabi::Token::Address(ethabi::Address::from_slice(& self
                            .delegated_request.3))
                        ],
                    ),
                ],
            );
            let mut encoded = Vec::with_capacity(4 + data.len());
            encoded.extend(Self::METHOD_ID);
            encoded.extend(data);
            encoded
        }
        pub fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            match call.input.get(0..4) {
                Some(signature) => Self::METHOD_ID == signature,
                None => false,
            }
        }
    }
    impl substreams_ethereum::Function for RevokeByDelegation {
        const NAME: &'static str = "revokeByDelegation";
        fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            Self::match_call(call)
        }
        fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            Self::decode(call)
        }
        fn encode(&self) -> Vec<u8> {
            self.encode()
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct RevokeOffchain {
        pub data: [u8; 32usize],
    }
    impl RevokeOffchain {
        const METHOD_ID: [u8; 4] = [207u8, 25u8, 15u8, 52u8];
        pub fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            let maybe_data = call.input.get(4..);
            if maybe_data.is_none() {
                return Err("no data to decode".to_string());
            }
            let mut values = ethabi::decode(
                    &[ethabi::ParamType::FixedBytes(32usize)],
                    maybe_data.unwrap(),
                )
                .map_err(|e| format!("unable to decode call.input: {:?}", e))?;
            values.reverse();
            Ok(Self {
                data: {
                    let mut result = [0u8; 32];
                    let v = values
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_fixed_bytes()
                        .expect(INTERNAL_ERR);
                    result.copy_from_slice(&v);
                    result
                },
            })
        }
        pub fn encode(&self) -> Vec<u8> {
            let data = ethabi::encode(
                &[ethabi::Token::FixedBytes(self.data.as_ref().to_vec())],
            );
            let mut encoded = Vec::with_capacity(4 + data.len());
            encoded.extend(Self::METHOD_ID);
            encoded.extend(data);
            encoded
        }
        pub fn output_call(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<substreams::scalar::BigInt, String> {
            Self::output(call.return_data.as_ref())
        }
        pub fn output(data: &[u8]) -> Result<substreams::scalar::BigInt, String> {
            let mut values = ethabi::decode(
                    &[ethabi::ParamType::Uint(64usize)],
                    data.as_ref(),
                )
                .map_err(|e| format!("unable to decode output data: {:?}", e))?;
            Ok({
                let mut v = [0 as u8; 32];
                values
                    .pop()
                    .expect("one output data should have existed")
                    .into_uint()
                    .expect(INTERNAL_ERR)
                    .to_big_endian(v.as_mut_slice());
                substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
            })
        }
        pub fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            match call.input.get(0..4) {
                Some(signature) => Self::METHOD_ID == signature,
                None => false,
            }
        }
        pub fn call(&self, address: Vec<u8>) -> Option<substreams::scalar::BigInt> {
            use substreams_ethereum::pb::eth::rpc;
            let rpc_calls = rpc::RpcCalls {
                calls: vec![rpc::RpcCall { to_addr : address, data : self.encode(), }],
            };
            let responses = substreams_ethereum::rpc::eth_call(&rpc_calls).responses;
            let response = responses.get(0).expect("one response should have existed");
            if response.failed {
                return None;
            }
            match Self::output(response.raw.as_ref()) {
                Ok(data) => Some(data),
                Err(err) => {
                    use substreams_ethereum::Function;
                    substreams::log::info!(
                        "Call output for function `{}` failed to decode with error: {}",
                        Self::NAME, err
                    );
                    None
                }
            }
        }
    }
    impl substreams_ethereum::Function for RevokeOffchain {
        const NAME: &'static str = "revokeOffchain";
        fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            Self::match_call(call)
        }
        fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            Self::decode(call)
        }
        fn encode(&self) -> Vec<u8> {
            self.encode()
        }
    }
    impl substreams_ethereum::rpc::RPCDecodable<substreams::scalar::BigInt>
    for RevokeOffchain {
        fn output(data: &[u8]) -> Result<substreams::scalar::BigInt, String> {
            Self::output(data)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct Timestamp {
        pub data: [u8; 32usize],
    }
    impl Timestamp {
        const METHOD_ID: [u8; 4] = [77u8, 0u8, 48u8, 112u8];
        pub fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            let maybe_data = call.input.get(4..);
            if maybe_data.is_none() {
                return Err("no data to decode".to_string());
            }
            let mut values = ethabi::decode(
                    &[ethabi::ParamType::FixedBytes(32usize)],
                    maybe_data.unwrap(),
                )
                .map_err(|e| format!("unable to decode call.input: {:?}", e))?;
            values.reverse();
            Ok(Self {
                data: {
                    let mut result = [0u8; 32];
                    let v = values
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_fixed_bytes()
                        .expect(INTERNAL_ERR);
                    result.copy_from_slice(&v);
                    result
                },
            })
        }
        pub fn encode(&self) -> Vec<u8> {
            let data = ethabi::encode(
                &[ethabi::Token::FixedBytes(self.data.as_ref().to_vec())],
            );
            let mut encoded = Vec::with_capacity(4 + data.len());
            encoded.extend(Self::METHOD_ID);
            encoded.extend(data);
            encoded
        }
        pub fn output_call(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<substreams::scalar::BigInt, String> {
            Self::output(call.return_data.as_ref())
        }
        pub fn output(data: &[u8]) -> Result<substreams::scalar::BigInt, String> {
            let mut values = ethabi::decode(
                    &[ethabi::ParamType::Uint(64usize)],
                    data.as_ref(),
                )
                .map_err(|e| format!("unable to decode output data: {:?}", e))?;
            Ok({
                let mut v = [0 as u8; 32];
                values
                    .pop()
                    .expect("one output data should have existed")
                    .into_uint()
                    .expect(INTERNAL_ERR)
                    .to_big_endian(v.as_mut_slice());
                substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
            })
        }
        pub fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            match call.input.get(0..4) {
                Some(signature) => Self::METHOD_ID == signature,
                None => false,
            }
        }
        pub fn call(&self, address: Vec<u8>) -> Option<substreams::scalar::BigInt> {
            use substreams_ethereum::pb::eth::rpc;
            let rpc_calls = rpc::RpcCalls {
                calls: vec![rpc::RpcCall { to_addr : address, data : self.encode(), }],
            };
            let responses = substreams_ethereum::rpc::eth_call(&rpc_calls).responses;
            let response = responses.get(0).expect("one response should have existed");
            if response.failed {
                return None;
            }
            match Self::output(response.raw.as_ref()) {
                Ok(data) => Some(data),
                Err(err) => {
                    use substreams_ethereum::Function;
                    substreams::log::info!(
                        "Call output for function `{}` failed to decode with error: {}",
                        Self::NAME, err
                    );
                    None
                }
            }
        }
    }
    impl substreams_ethereum::Function for Timestamp {
        const NAME: &'static str = "timestamp";
        fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            Self::match_call(call)
        }
        fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            Self::decode(call)
        }
        fn encode(&self) -> Vec<u8> {
            self.encode()
        }
    }
    impl substreams_ethereum::rpc::RPCDecodable<substreams::scalar::BigInt>
    for Timestamp {
        fn output(data: &[u8]) -> Result<substreams::scalar::BigInt, String> {
            Self::output(data)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct Version {}
    impl Version {
        const METHOD_ID: [u8; 4] = [84u8, 253u8, 77u8, 80u8];
        pub fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            Ok(Self {})
        }
        pub fn encode(&self) -> Vec<u8> {
            let data = ethabi::encode(&[]);
            let mut encoded = Vec::with_capacity(4 + data.len());
            encoded.extend(Self::METHOD_ID);
            encoded.extend(data);
            encoded
        }
        pub fn output_call(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<String, String> {
            Self::output(call.return_data.as_ref())
        }
        pub fn output(data: &[u8]) -> Result<String, String> {
            let mut values = ethabi::decode(&[ethabi::ParamType::String], data.as_ref())
                .map_err(|e| format!("unable to decode output data: {:?}", e))?;
            Ok(
                values
                    .pop()
                    .expect("one output data should have existed")
                    .into_string()
                    .expect(INTERNAL_ERR),
            )
        }
        pub fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            match call.input.get(0..4) {
                Some(signature) => Self::METHOD_ID == signature,
                None => false,
            }
        }
        pub fn call(&self, address: Vec<u8>) -> Option<String> {
            use substreams_ethereum::pb::eth::rpc;
            let rpc_calls = rpc::RpcCalls {
                calls: vec![rpc::RpcCall { to_addr : address, data : self.encode(), }],
            };
            let responses = substreams_ethereum::rpc::eth_call(&rpc_calls).responses;
            let response = responses.get(0).expect("one response should have existed");
            if response.failed {
                return None;
            }
            match Self::output(response.raw.as_ref()) {
                Ok(data) => Some(data),
                Err(err) => {
                    use substreams_ethereum::Function;
                    substreams::log::info!(
                        "Call output for function `{}` failed to decode with error: {}",
                        Self::NAME, err
                    );
                    None
                }
            }
        }
    }
    impl substreams_ethereum::Function for Version {
        const NAME: &'static str = "version";
        fn match_call(call: &substreams_ethereum::pb::eth::v2::Call) -> bool {
            Self::match_call(call)
        }
        fn decode(
            call: &substreams_ethereum::pb::eth::v2::Call,
        ) -> Result<Self, String> {
            Self::decode(call)
        }
        fn encode(&self) -> Vec<u8> {
            self.encode()
        }
    }
    impl substreams_ethereum::rpc::RPCDecodable<String> for Version {
        fn output(data: &[u8]) -> Result<String, String> {
            Self::output(data)
        }
    }
}
/// Contract's events.
#[allow(dead_code, unused_imports, unused_variables)]
pub mod events {
    use super::INTERNAL_ERR;
    #[derive(Debug, Clone, PartialEq)]
    pub struct Attested {
        pub recipient: Vec<u8>,
        pub attester: Vec<u8>,
        pub uid: [u8; 32usize],
        pub schema: [u8; 32usize],
    }
    impl Attested {
        const TOPIC_ID: [u8; 32] = [
            139u8,
            244u8,
            107u8,
            244u8,
            207u8,
            214u8,
            116u8,
            250u8,
            115u8,
            90u8,
            61u8,
            99u8,
            236u8,
            28u8,
            154u8,
            212u8,
            21u8,
            63u8,
            3u8,
            60u8,
            41u8,
            3u8,
            65u8,
            243u8,
            165u8,
            136u8,
            183u8,
            86u8,
            133u8,
            20u8,
            27u8,
            53u8,
        ];
        pub fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            if log.topics.len() != 4usize {
                return false;
            }
            if log.data.len() != 32usize {
                return false;
            }
            return log.topics.get(0).expect("bounds already checked").as_ref() as &[u8]
                == Self::TOPIC_ID;
        }
        pub fn decode(
            log: &substreams_ethereum::pb::eth::v2::Log,
        ) -> Result<Self, String> {
            let mut values = ethabi::decode(
                    &[ethabi::ParamType::FixedBytes(32usize)],
                    log.data.as_ref(),
                )
                .map_err(|e| format!("unable to decode log.data: {:?}", e))?;
            values.reverse();
            Ok(Self {
                recipient: ethabi::decode(
                        &[ethabi::ParamType::Address],
                        log.topics[1usize].as_ref(),
                    )
                    .map_err(|e| {
                        format!(
                            "unable to decode param 'recipient' from topic of type 'address': {:?}",
                            e
                        )
                    })?
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_address()
                    .expect(INTERNAL_ERR)
                    .as_bytes()
                    .to_vec(),
                attester: ethabi::decode(
                        &[ethabi::ParamType::Address],
                        log.topics[2usize].as_ref(),
                    )
                    .map_err(|e| {
                        format!(
                            "unable to decode param 'attester' from topic of type 'address': {:?}",
                            e
                        )
                    })?
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_address()
                    .expect(INTERNAL_ERR)
                    .as_bytes()
                    .to_vec(),
                schema: {
                    let mut result = [0u8; 32];
                    let v = ethabi::decode(
                            &[ethabi::ParamType::FixedBytes(32usize)],
                            log.topics[3usize].as_ref(),
                        )
                        .map_err(|e| {
                            format!(
                                "unable to decode param 'schema' from topic of type 'bytes32': {:?}",
                                e
                            )
                        })?
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_fixed_bytes()
                        .expect(INTERNAL_ERR);
                    result.copy_from_slice(&v);
                    result
                },
                uid: {
                    let mut result = [0u8; 32];
                    let v = values
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_fixed_bytes()
                        .expect(INTERNAL_ERR);
                    result.copy_from_slice(&v);
                    result
                },
            })
        }
    }
    impl substreams_ethereum::Event for Attested {
        const NAME: &'static str = "Attested";
        fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            Self::match_log(log)
        }
        fn decode(log: &substreams_ethereum::pb::eth::v2::Log) -> Result<Self, String> {
            Self::decode(log)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct Revoked {
        pub recipient: Vec<u8>,
        pub attester: Vec<u8>,
        pub uid: [u8; 32usize],
        pub schema: [u8; 32usize],
    }
    impl Revoked {
        const TOPIC_ID: [u8; 32] = [
            249u8,
            48u8,
            166u8,
            226u8,
            82u8,
            60u8,
            156u8,
            194u8,
            152u8,
            105u8,
            24u8,
            115u8,
            8u8,
            122u8,
            116u8,
            5u8,
            80u8,
            184u8,
            252u8,
            133u8,
            160u8,
            104u8,
            8u8,
            48u8,
            65u8,
            76u8,
            20u8,
            142u8,
            217u8,
            39u8,
            246u8,
            21u8,
        ];
        pub fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            if log.topics.len() != 4usize {
                return false;
            }
            if log.data.len() != 32usize {
                return false;
            }
            return log.topics.get(0).expect("bounds already checked").as_ref() as &[u8]
                == Self::TOPIC_ID;
        }
        pub fn decode(
            log: &substreams_ethereum::pb::eth::v2::Log,
        ) -> Result<Self, String> {
            let mut values = ethabi::decode(
                    &[ethabi::ParamType::FixedBytes(32usize)],
                    log.data.as_ref(),
                )
                .map_err(|e| format!("unable to decode log.data: {:?}", e))?;
            values.reverse();
            Ok(Self {
                recipient: ethabi::decode(
                        &[ethabi::ParamType::Address],
                        log.topics[1usize].as_ref(),
                    )
                    .map_err(|e| {
                        format!(
                            "unable to decode param 'recipient' from topic of type 'address': {:?}",
                            e
                        )
                    })?
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_address()
                    .expect(INTERNAL_ERR)
                    .as_bytes()
                    .to_vec(),
                attester: ethabi::decode(
                        &[ethabi::ParamType::Address],
                        log.topics[2usize].as_ref(),
                    )
                    .map_err(|e| {
                        format!(
                            "unable to decode param 'attester' from topic of type 'address': {:?}",
                            e
                        )
                    })?
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_address()
                    .expect(INTERNAL_ERR)
                    .as_bytes()
                    .to_vec(),
                schema: {
                    let mut result = [0u8; 32];
                    let v = ethabi::decode(
                            &[ethabi::ParamType::FixedBytes(32usize)],
                            log.topics[3usize].as_ref(),
                        )
                        .map_err(|e| {
                            format!(
                                "unable to decode param 'schema' from topic of type 'bytes32': {:?}",
                                e
                            )
                        })?
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_fixed_bytes()
                        .expect(INTERNAL_ERR);
                    result.copy_from_slice(&v);
                    result
                },
                uid: {
                    let mut result = [0u8; 32];
                    let v = values
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_fixed_bytes()
                        .expect(INTERNAL_ERR);
                    result.copy_from_slice(&v);
                    result
                },
            })
        }
    }
    impl substreams_ethereum::Event for Revoked {
        const NAME: &'static str = "Revoked";
        fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            Self::match_log(log)
        }
        fn decode(log: &substreams_ethereum::pb::eth::v2::Log) -> Result<Self, String> {
            Self::decode(log)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct RevokedOffchain {
        pub revoker: Vec<u8>,
        pub data: [u8; 32usize],
        pub timestamp: substreams::scalar::BigInt,
    }
    impl RevokedOffchain {
        const TOPIC_ID: [u8; 32] = [
            146u8,
            161u8,
            247u8,
            164u8,
            26u8,
            124u8,
            88u8,
            90u8,
            139u8,
            9u8,
            226u8,
            91u8,
            25u8,
            94u8,
            34u8,
            91u8,
            29u8,
            67u8,
            36u8,
            141u8,
            172u8,
            164u8,
            107u8,
            15u8,
            175u8,
            158u8,
            7u8,
            146u8,
            119u8,
            122u8,
            34u8,
            41u8,
        ];
        pub fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            if log.topics.len() != 4usize {
                return false;
            }
            if log.data.len() != 0usize {
                return false;
            }
            return log.topics.get(0).expect("bounds already checked").as_ref() as &[u8]
                == Self::TOPIC_ID;
        }
        pub fn decode(
            log: &substreams_ethereum::pb::eth::v2::Log,
        ) -> Result<Self, String> {
            Ok(Self {
                revoker: ethabi::decode(
                        &[ethabi::ParamType::Address],
                        log.topics[1usize].as_ref(),
                    )
                    .map_err(|e| {
                        format!(
                            "unable to decode param 'revoker' from topic of type 'address': {:?}",
                            e
                        )
                    })?
                    .pop()
                    .expect(INTERNAL_ERR)
                    .into_address()
                    .expect(INTERNAL_ERR)
                    .as_bytes()
                    .to_vec(),
                data: {
                    let mut result = [0u8; 32];
                    let v = ethabi::decode(
                            &[ethabi::ParamType::FixedBytes(32usize)],
                            log.topics[2usize].as_ref(),
                        )
                        .map_err(|e| {
                            format!(
                                "unable to decode param 'data' from topic of type 'bytes32': {:?}",
                                e
                            )
                        })?
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_fixed_bytes()
                        .expect(INTERNAL_ERR);
                    result.copy_from_slice(&v);
                    result
                },
                timestamp: {
                    let mut v = [0 as u8; 32];
                    ethabi::decode(
                            &[ethabi::ParamType::Uint(64usize)],
                            log.topics[3usize].as_ref(),
                        )
                        .map_err(|e| {
                            format!(
                                "unable to decode param 'timestamp' from topic of type 'uint64': {:?}",
                                e
                            )
                        })?
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_uint()
                        .expect(INTERNAL_ERR)
                        .to_big_endian(v.as_mut_slice());
                    substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                },
            })
        }
    }
    impl substreams_ethereum::Event for RevokedOffchain {
        const NAME: &'static str = "RevokedOffchain";
        fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            Self::match_log(log)
        }
        fn decode(log: &substreams_ethereum::pb::eth::v2::Log) -> Result<Self, String> {
            Self::decode(log)
        }
    }
    #[derive(Debug, Clone, PartialEq)]
    pub struct Timestamped {
        pub data: [u8; 32usize],
        pub timestamp: substreams::scalar::BigInt,
    }
    impl Timestamped {
        const TOPIC_ID: [u8; 32] = [
            90u8,
            175u8,
            206u8,
            235u8,
            28u8,
            122u8,
            213u8,
            142u8,
            74u8,
            132u8,
            137u8,
            139u8,
            222u8,
            227u8,
            124u8,
            2u8,
            192u8,
            252u8,
            70u8,
            231u8,
            210u8,
            78u8,
            107u8,
            96u8,
            232u8,
            32u8,
            148u8,
            73u8,
            241u8,
            131u8,
            69u8,
            159u8,
        ];
        pub fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            if log.topics.len() != 3usize {
                return false;
            }
            if log.data.len() != 0usize {
                return false;
            }
            return log.topics.get(0).expect("bounds already checked").as_ref() as &[u8]
                == Self::TOPIC_ID;
        }
        pub fn decode(
            log: &substreams_ethereum::pb::eth::v2::Log,
        ) -> Result<Self, String> {
            Ok(Self {
                data: {
                    let mut result = [0u8; 32];
                    let v = ethabi::decode(
                            &[ethabi::ParamType::FixedBytes(32usize)],
                            log.topics[1usize].as_ref(),
                        )
                        .map_err(|e| {
                            format!(
                                "unable to decode param 'data' from topic of type 'bytes32': {:?}",
                                e
                            )
                        })?
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_fixed_bytes()
                        .expect(INTERNAL_ERR);
                    result.copy_from_slice(&v);
                    result
                },
                timestamp: {
                    let mut v = [0 as u8; 32];
                    ethabi::decode(
                            &[ethabi::ParamType::Uint(64usize)],
                            log.topics[2usize].as_ref(),
                        )
                        .map_err(|e| {
                            format!(
                                "unable to decode param 'timestamp' from topic of type 'uint64': {:?}",
                                e
                            )
                        })?
                        .pop()
                        .expect(INTERNAL_ERR)
                        .into_uint()
                        .expect(INTERNAL_ERR)
                        .to_big_endian(v.as_mut_slice());
                    substreams::scalar::BigInt::from_unsigned_bytes_be(&v)
                },
            })
        }
    }
    impl substreams_ethereum::Event for Timestamped {
        const NAME: &'static str = "Timestamped";
        fn match_log(log: &substreams_ethereum::pb::eth::v2::Log) -> bool {
            Self::match_log(log)
        }
        fn decode(log: &substreams_ethereum::pb::eth::v2::Log) -> Result<Self, String> {
            Self::decode(log)
        }
    }
}